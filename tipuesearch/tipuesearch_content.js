var tipuesearch = {"pages":[{"title":"arduino的IIC通信","url":"/2024/12/29/arduino的IIC通信/","text":"arduino的IIC首先arduino的IIC是硬件IIC，硬件IIC一般都是固定引脚的所以需要自己先去查一下自己芯片的第一组IIC接口是哪两个引脚(esp32例外)然后，需要芯片支持Wire.h库。一般芯片都会自带有的。(这是官方库)最后说明：读写缓存只有 32 字节文件宏定义： //这个为IIC头文件 #include &lt;Wire.h&gt; // esp32iic可以是任意的IO 主机模式IIC初始化Wire.begin(address); // 初始化IIC 参数 数据类型 作用 选项 address int 注册成为从机模式 0到128之间 返回值 无 无 无 Wire.begin(); // 初始化IIC 参数 数据类型 作用 选项 无 无 啥也不填直接调用就是主机模式 无 返回值 无 无 无 esp32iic可以是任意的IO 所以 初始化主机模式Wire.begin(sda,scl); // 初始化IIC 参数 数据类型 作用 选项 sda int 定义sda的引脚 单片机引脚 scl int 定义scl的引脚 单片机引脚 返回值 无 无 无 初始化从机模式Wire.begin(sda,scl,address); // 初始化IIC 参数 数据类型 作用 选项 sda int 定义sda的引脚 单片机引脚 scl int 定义scl的引脚 单片机引脚 address int 注册成为从机模式 0到128之间 返回值 无 无 无 主机准备向从机读数据Wire.requrstFrom(addtess,quantity) Wire.requrstFrom(addtess,quantity,stop) 参数 数据类型 作用 选项 address int 向指定从机请求数据 0到128之间 quantity int 请求数据的长度（单位字节） 0到32之间 stop 布尔形 ‘真’ 则在请求结束后发送一个停止命令，并释放总线。‘假’则继续发送请求保持连接 真或者假 返回值 int 主机从从机接受到的字节数目，主机接受到一个数据返回的字节数就会减少一个 无 主机准备向从机写数据Wire.beginTransmission(addtess); 参数 数据类型 作用 选项 address int 向指定从机请求数据 0到128之间 返回值 无 无 无 发送停止位Wire.endTransmission() Wire.endTransmission(stop) 参数 数据类型 作用 选项 stop 布尔形 ‘真’ 发送一个停止信息，并释放总线。‘假’则继续发送请求保持连接 真或者假 返回值 int 0、成功 1、数据溢出 2、发送addtess时从机接受到NACK 3、发送数据时接受到 NACK 4、其他错误 无 发送数据Wire.write(value) Wire.write(string) Wire.write(data, length) 参数 数据类型 作用 选项 value int 要发送的数值 int string string 发送的字符组的指针 字符组 data 数组 要发送的数组 数组 length int 发送的数组的长度（单位字节） int 返回值 无 无 无 返回读到的字节数Wire. available() 参数 数据类型 作用 选项 返回值 int 主机从从机接受到的字节数目，主机接受到一个数据返回的字节数就会减少一个 无 读取数据Wire.read() 参数 数据类型 作用 选项 返回值 uint8_t 读到的字节数据，通常一次返回一个字节的数据 无 从机模式当从机接受到主机写的请求Wire.onReceive(handler) 参数 数据类型 作用 选项 handler 回调函数 当从机接受到数据就执行回调函数,回调函数需要带一个int型参数（无返回值） void handler(int howMany){} 返回值 uint8_t 主机从从机接受到的字节数目，主机接受到一个数据返回的字节数就会减少一个 无 当从机接受到主机读的请求Wire.onRequest(handler) 参数 数据类型 作用 选项 handler 回调函数 当从机接受到数据就执行回调函数（无返回值） 回调函数 返回值 uint8_t 主机从从机接受到的字节数目，主机接受到一个数据返回的字节数就会减少一个 无 参考代码bh1750通信//addr接高电平设备地址为1011100也就是0x5c //低电平0100011也就是0x23 uint8_t data[1]; uint16_t Rx_Data; int i; #include &lt;Wire.h&gt; void setup() &#123; // put your setup code here, to run once: Wire.begin(); Serial.begin(115200); bh711 (); &#125; void loop() &#123; // put your main code here, to run repeatedly i=0; Wire.requestFrom(0x5c, 2);//请求两个字节数据 // 当从从设备接收到信息时值为true while (Wire.available()) &#123; Serial.println(i); // 接受并读取从设备发来的一个字节的数据 data[i] = Wire.read(); i++; // 向串口打印该字节 if (i=2) &#123; Rx_Data = ((uint16_t)data[0] &lt;&lt; 8) + data[1];//0高位1地位 &#125; &#125; Serial.println(Rx_Data/ 1.2f);//合并数据并打印 delay(500); &#125; void bh711 () &#123; Wire.beginTransmission(0x5c);//请求设备地址 Wire.write(0x00);//关闭电源 Wire.endTransmission();//结束通信 Wire.beginTransmission(0x5c); Wire.write(0x01);//打开电源 Wire.endTransmission(); Wire.beginTransmission(0x5c); Wire.write(0x07);//初始化扫描 Wire.endTransmission(); Wire.beginTransmission(0x5c); Wire.write(0x11);//连续h分辨率模式2 Wire.endTransmission(); &#125; 从机和主机通信目前已知air001（py32f002a）iic从机有问题从机代码 #include &lt;Wire.h&gt; #define I2C_ADDR 2 int a; char adb[0]; void setup() &#123; Wire.begin(I2C_ADDR); // join i2c bus with address #4 Wire.onRequest(requestEvent); // register event Wire.onReceive(receiveEvent); // register event Serial.begin(9600); // start serial for output &#125; void loop() &#123; //empty loop &#125; // function that executes whenever data is received from master // this function is registered as an event, see setup() void receiveEvent(int howMany) &#123; a++; int cc; while( Wire.available()) // loop through all but the last &#123; cc = Wire.read(); // receive byte as a character if (cc) &#123; a++; &#125; //Serial.print(cc); // print the character &#125; //int x = Wire.read(); // receive byte as an integer &#125; // function that executes whenever data is requested by master // this function is registered as an event, see setup() void requestEvent() &#123; sprintf(adb, &quot;%d&quot;,a); Wire.write(a); // respond with message of 6 bytes // as expected by master &#125; 主机代码 #include &lt;Wire.h&gt; void setup() &#123; // put your setup code here, to run once: Wire.begin(); Serial.begin(115200); &#125; void loop() &#123; // put your main code here, to run repeatedly: // 向从设备＃8请求1个字节 Wire.requestFrom(2, 1); // 当从从设备接收到信息时值为true while (Wire.available()) &#123; // 接受并读取从设备发来的一个字节的数据 char c = Wire.read(); // 向串口打印该字节 Serial.print(c); &#125; Wire.endTransmission(); Wire.beginTransmission(2); Wire.write(0x78); Wire.endTransmission(); delay(500); &#125;","tags":"arduino"},{"title":"arduino的spi通信","url":"/2024/12/29/arduino的spi通信/","text":"arduino的spi串行外围设备接口（SPI）是微控制器使用的同步串行数据协议，用于在短距离内快速与一个或多个外围设备进行通信。它也可以用于两个开发板之间相互的通信。 使用SPI连接，总是有一个主设备（通常是微控制器）来控制外围设备。通常，所有设备共用以下三条线： MISO（Master In Slave Out）-从机线路，用于向主机发送数据，MOSI（Master Out Slave In）-主机线路，用于向外围设备发送数据，SCK（串行时钟）-同步主机产生的数据传输的时钟脉冲 每个从设备专用的一条线： SS（从设备选择）-主设备可用此引脚来决定启用或禁用指定设备。当从设备的CS引脚为低电平时，它与主机通信。同理CS引脚电平为高时，它将忽略连接到CS引脚的设备, 不与之进行数据交互。文件宏定义： //这个为SPI头文件 #include &lt;SPI.h&gt; // 主机模式spi初始化SPI.begin() 参数 数据类型 作用 选项 返回值 无 无 无 初始化SPI通信，调用该函数后，SCK&#x2F;MOSI&#x2F;SS引脚将被设置为输出模式且SCK&#x2F;MOSI引脚拉低，SS引脚拉高 spi模式自定义初始化SPI.beginTransaction(SPISettings mySettting(speedMaximum, dataOrder, dataMode)); SPI.beginTransaction(SPISettings(14000000, MSBFIRST, SPI_MODE0)); SPISettings mySettting(speedMaximum, dataOrder, dataMode) SPI.beginTransaction(SPISettings(14000000, MSBFIRST, SPI_MODE0))//默认设置 参数 数据类型 作用 选项 speedMaximum int 最高的通讯速度 看自己spi的芯片通信速率 dataOrder int 数据传输顺序选择 LSBFIRST(0)&#x2F;&#x2F;低位在前MSBFIRST(1)&#x2F;&#x2F;高位在前 dataMode int spi通信模式 SPI_MODE0 (0x00)SPI_MODE1 (0x01)SPI_MODE2 (0x02)SPI_MODE3 (0x03) 返回值 无 无 无 模式 时钟极性 （CPOL） 时钟相位 （CPHA） 输出边缘 数据捕获 SPI_MODE0 0 0 下降 上升 SPI_MODE1 0 1 上升 下降 SPI_MODE2 1 0 上升 下降 SPI_MODE3 1 1 下降 上升 使用SPI.beginTransaction()函数初始化spi总线，该函数的参数 停止全部spi总线SPI.end() 参数 数据类型 作用 选项 返回值 无 无 无 （在初始化时设置的各个引脚输出模式将不会改变）。 停止部分使用SPI总线。SPI.endTransaction() 参数 数据类型 作用 选项 返回值 无 无 无 通常在禁用某引脚上的从设备后调用此函数 以允许其他库使用SPI总线。 设定spi传输是高位还是低位SPI.setBitOrder(order) 参数 数据类型 作用 选项 order int 数据传输顺序选择 LSBFIRST(0)&#x2F;&#x2F;低位在前MSBFIRST(1)&#x2F;&#x2F;高位在前 返回值 无 无 无 设定spi传输时钟SPI.setClockDivider（divider） 参数 数据类型 作用 选项 divider int 通信时钟系统时钟分频 SPI_CLOCK_DIV2(2)&#x2F;&#x2F;2分频SPI_CLOCK_DIV4(4)&#x2F;&#x2F;4分频SPI_CLOCK_DIV8(8)&#x2F;&#x2F;8分频SPI_CLOCK_DIV16(16)&#x2F;&#x2F;16分频SPI_CLOCK_DIV32(32)&#x2F;&#x2F;32分频SPI_CLOCK_DIV64(64)&#x2F;&#x2F;64分频SPI_CLOCK_DIV128(128)&#x2F;&#x2F;128分频 返回值 无 无 无 设定spi传输模式SPI.setDataMode（mode） 参数 数据类型 作用 选项 Mode int spi通信模式 SPI_MODE0 (0x00)SPI_MODE1 (0x01)SPI_MODE2 (0x02)SPI_MODE3 (0x03) 返回值 无 无 无 SPI_MODE0（上升沿采样，下降沿置位，SCK闲置时为0），SPI_MODE1（上升沿置位，下降沿采样，SCK闲置时为0），SPI_MODE2（下降沿采样，上升沿置位，SCK闲置时为1），SPI_MODE3（下降沿置位，上升沿采样，SCK闲置时为1）。 设定spi输入还有输出SPI.transfer(val) SPI.transfer16(val16) SPI.transfer(buffer, size) 参数 数据类型 作用 选项 val uint8_t 通过总线发送的字节 无 val16 int 通过总线发送的两个字节变量 无 buffer int 要传输的数据数组 无 size int 传输数据的字节长度（单位字节） 无 返回值 int 返回读取的数据 无 SPI通讯是在中断SPI.usingInterrupt(interruptNumber) 参数 数据类型 作用 选项 interruptNumber int 中断编号 支持中断的io 返回值 无 无 无","tags":"arduino"},{"title":"arduino的DHT11","url":"/2024/12/28/arduino的DHT11/","text":"arduino的DHT11芯片手册： 芯系列DHT11温湿度传感器 芯片库下载：https://github.com/adafruit/DHT-sensor-libraryhttps://github.com/adafruit/Adafruit_Sensor(以上两个文件都要下载) 头文件加宏定义： //这个为DHT11头文件 #include &lt;DHT.h&gt; #include &lt;DHT_U.h&gt; // 创建DHT对象 #define DHTPIN 4 // 设置获取数据的引脚 #define DHTTYPE DHT11 // 选择DHT11 DHT dht(DHTPIN, DHTTYPE); // 创建一个DHT对象 传感器初始化dht.begin(); // 初始化DHT11 参数 数据类型 作用 选项 返回值 无 无 无 读取湿度dht.readHumidity(); // 读取湿度 参数 数据类型 作用 选项 返回值 float 读取湿度 无 读取温度dht.readTemperature(); // 读取温度 参数 数据类型 作用 选项 返回值 float 读取温度 无 判断是否启动正常if (isnan(h) || isnan(t)) &#123; Serial.println(&quot;DHT11数据读取失败&quot;); return; &#125; 参考代码: #include &lt;DHT.h&gt; #include &lt;DHT_U.h&gt; #define DHTPIN PB1 #define DHTTYPE DHT11 DHT dht(DHTPIN, DHTTYPE); void setup() &#123; Serial.begin(115200); dht.begin(); // 初始化DHT11 &#125; void loop() &#123; // 暂停2秒，读取数据官方说明需要250毫秒 delay(2000); // 读取传感器数据 float h = dht.readHumidity(); // 读取湿度 float t = dht.readTemperature(); // 读取温度 // 判断数据是否成功读取 if (isnan(h) || isnan(t)) &#123; Serial.println(&quot;DHT11数据读取失败&quot;); return; &#125; // 串口打印 Serial.print (&quot;湿度: &quot;); Serial.print (h); Serial.print (&quot;% | &quot;); Serial.print (&quot;温度度: &quot;); Serial.print (t); Serial.println (&quot;℃&quot;); &#125;","tags":"arduino esp32"},{"title":"芯系列DHT11温湿度传感器","url":"/2024/12/27/芯系列DHT11温湿度传感器/","text":"DHT11 手册下载：https://wwwe.lanzouq.com/b007t5inji密码:aqyc 介绍：DHT11是一款有已校准数字信号输出的温湿度传感器。 其精度湿度±5%RH， 温度±2℃，量程湿度5~95%RH， 温度-20~+60℃。 荐的存储环境温度：10~40℃ 湿度：60%RH以下。暴露在化学物质中的影响电容式湿度传感器的感应层会受到化学蒸汽的干扰，化学物质在感应层中的扩散可能导致测量值漂移和灵敏度下降。在一个纯净的环境中，污染物质会缓慢地释放出去。下文所述的恢复处理将加速实现这一过程。高浓度的化学污染会导致传感器感应层的彻底损坏。 pin 名称 功能 1 VDD 供电 3－5.5VDC 2 DATA 串行数据，单总线 3 NC 空脚 4 GND 地线 产品封装 工作时序：DHT11 整体工作时序为：主机发送开始信号、DHT11 响应输出、主机接收 40bit 数据（湿度数据+温度数据+校验值），结束信号（可选）。具体过程如下： 总线空闲状态为高电平，主机拉低总线等待 DHT11 响应, 主机把总线拉低必须大于 18ms，保证 DHT11 能检测到起始信号；主机发送开始信号结束后，拉高总线电平并延时等待 20-40us 后，读取 DHT11 的响应信号；DHT11 接收到主机的开始信号后，等待微处理器开始信号结束，发送 80us 低电平响应信号；DHT11 发送 80us 高电平准备发送数据；DHT11 发送 40bit 数据（湿度数据+温度数据+校验值）。 大概的一个通信流程 DHT11 开始传输数据。每 1bit 数据都以 50us 低电平开始，告诉主机开始传输一位数据了。DHT11 以高电平的长短定义数据位是 0 还是 1：当 50us 低电平过后拉高总线，高电平持续 26~28us 表示 0，高电平持续 70us 表示数据 1。 当最后 1bit 数据传送完毕后，DHT11 拉低总线 50us，表示数据传输完毕，随后总线由上拉电阻拉高进入空闲状态。 以 50us 低电平开始，高电平持续 26~28us 表示 0 以 50us 低电平开始，高电平持续 70us 表示 0 DHT11 的 DATA 传输一次完整的数据为 40bit，按照高位在前，低位在后的顺序传输。 数据格式为：8bit 湿度整数数据 + 8bit 湿度小数数据 + 8bit 温度整数数据 + 8bit 温度小数数据 + 8bit 校验位，一共 5 字节（40bit）数据。 正常情况下，前四个字节的和刚好与校验位相等，通过这种机制可以保证数据传输的准确性。","tags":"芯片手册"},{"title":"arduino的oled","url":"/2024/12/16/arduino的oled/","text":"arduino的oled芯片手册： 芯系列0.96oled(SSD1306) 请确保你的芯片支持&lt;Wire.h&gt;或者&lt;SPI.h&gt;的库否则不做支持具体引脚请看自己的芯片不做过多叙述 头文件加宏定义： //这个为IIC屏 #include &lt;SPI.h&gt;//spi库 #include &lt;Wire.h&gt;//iic库 #include &lt;Adafruit_GFX.h&gt;//适配很多种屏幕显示图形字体的一个功能库； #include &lt;Adafruit_SSD1306.h&gt;//适配驱动OLED屏显示芯片的库文件； #define SCREEN_WIDTH 128 //横向分辨率 x #define SCREEN_HEIGHT 64 //纵向向分辨率 yy #define OLED_RESET -1 //复位脚，一般屏幕没复位所以填-1 Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET); //第三个参数用于选择模式，&amp;Wire为iic模式，&amp;SPI为spi模式 oled初始化函数display.begin(SSD1306_SWITCHCAPVCC, 0x3C) SSD1306_SWITCHCAPVCC这个不知道0x3C为iic通信的设备的地址返回值：布尔值成功是1否则是0 清空屏幕信息display.clearDisplay(); 设置文本大小display.setTextSize(uint16_t s); s:为文本的大小，默认为1。其中1代表6 x 82代表12 x 163代表18 x 24以此类推。 设置屏幕颜色display.setTextColor(uint16_t c); c参数：SSD1306_BLACK（0）设置黑色SSD1306_WHITE（1）设置白色SSD1306_INVERSE（2）设置相反的颜色 设置显示屏显示旋转角度display.setRotation(uint8_t x) 参数：x为旋转角度，范围：0~3。默认为0。其中0代表旋转0度，1代表旋转90度2代表旋转180度，3代表旋转270度。 设置屏幕渲染的位置display.setCursor(x,y); 参数：x为文本的起始x坐标，y为文本的起始y坐标。范围：x，y均大于或等于0 在指定位置画一个不填充颜色的矩形display.drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) x:为矩形起始x坐标y：为矩形起始y坐标w：为矩形宽度h：为矩形高度color：为矩形边的颜色范围：x，y大于或等于0；w，h大于0，在Adafruit_SSD1306库中color的取值为SSD1306_BLACK，SSD1306_WHITE或SSD1306_INVERSE 在指定位置显示绘制位图display.drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w， int16_t h, uint16_t color) 在指定位置显示绘制位图，可用来在显示屏上显示中文。参数：x为图像起始x坐标，y为图像起始y坐标bitmap[]:为单色位图的字节数组w为位图宽度，h为位图高度color：为位图颜色。范围x，y均大于或等于0同上 打印屏幕display.display(); 将当前缓冲区中的数据推送到SSD1306 显示屏。即显示数据。 参考代码： IIC#include &lt;SPI.h&gt; #include &lt;Wire.h&gt; #include &lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #define SCREEN_WIDTH 128 #define SCREEN_HEIGHT 64 #define OLED_RESET -1 Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET); void ShowText(void); void setup() &#123; Serial.begin(9600);//初始化串口 if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) &#123; Serial.println(&quot;SSD1306 allocation failed&quot;); //等待屏幕初始化 while(1); &#125; ShowText(); &#125; void loop() &#123; // put your main code here, to run repeatedly: &#125; void ShowText(void) &#123; //清空屏幕信息 display.clearDisplay(); //设置文本字体大小为2 display.setTextSize(2); //设置屏幕颜色为白色 display.setTextColor(SSD1306_WHITE); //设置打印的起始坐标10,16 display.setCursor(10, 16); //设置显示的文本信息 display.println(F(&quot;happy day&quot;)); //将屏幕缓冲区数据刷到屏幕上，显示出来 display.display(); &#125; SPI开发ing","tags":"arduino esp32"},{"title":"芯系列0.96oled(SSD1306)","url":"/2024/12/16/芯系列0.96oled(SSD1306)/","text":"0.96oled(SSD1306)开发ing","tags":"芯片手册"},{"title":"openharmony用windows开发hi3861","url":"/2024/12/13/openharmony用windows开发hi3861/","text":"openharmony用windows开发hi3861首先下载vscode下载 下载完成后记得一路点安装，不要修改安装路径默认c盘 不要修改安装路径！不要修改安装路径！不要修改安装路径！ 安装vscod插件安装完成后打开vscode点击这里搜索输入 chinese安装简体中文点击重启应用中文重启后发现都变成汉化了继续点击插件，点击三个点点击VSIX安装 依次安装这四个文件 或者手动搜索安装下面的插件 安装华为开发环境官网：https://device.harmonyos.com/cn/develop/ide#download 下载完成后双击安装（记得关闭vscode） 别傻等着，如果没有python环境就点击安装啊！！！正在从官网下载然后等待他自动部署 导入SDK打开vscode，发现这里是不是多了一个小图标点他！！！点击主页，然后点导入工程 工程就是压缩包里面的东西导出来导入过点这里可以打开工程 安装工具链首先把编译工具解压出来点击工程配置，然后找到图片里面的位置导入上面解压出来的文件夹 编译代码点击左下角PROJECT TASKS里面的BUILD这样代表编译成功 clean清除编译的文件build 只编译修改过的地方rebuild 全部重头编译 关于烧录查看下面的文章不冲突 openharmony烧录hi3861芯片 关于源码位置参考代码：鸿蒙源码\\src\\vendor\\pzkj\\pz_hi3861\\demo 具体开发请看下面 openharmony南向开发教程","tags":"openharmony"},{"title":"openharmony用ubuntu编写串口","url":"/2024/12/12/openharmony用ubuntu编写串口/","text":"openharmony用ubuntu编写串口代码下载 第一部分：代码结构软件部分目录结构 UART ├─ BUILD.gn └─UART.c 我们打开文件代码打开voltage_buttons_thread.c hi3861 其中 UART 端口有 3 个，其中 UART0 用于调试，每个 GPIO 可复用成 UART 的端口如下： Pin 管脚名称 复用信号 2 GPIO_00 UART1_TXD 3 GPIO_01 UART1_RXD 4 GPIO_02 UART1_RTS， UART1 的流控管脚，发送请求信号，输出 5 GPIO_03 复用信号 0：UART0_LOG_TXD，数据发送， Debug 和下载串口接口 复用信号 1：UART1_CTS， UART1 的流控管脚，清除发送信号，输入 6 GPIO_04 UART0_LOG_RXD 数据接收， Debug 和下载串口接口 17 GPIO_05 UART1_RXD，数据接收口 18 GPIO_06 UART1_TXD，数据发送口 19 GPIO_07 UART1_CTS，清除发送信号，通信串口 20 GPIO_08 UART1_RTS，发送请求信号，通信串口 27 GPIO_09 UART2_RTS，发送请求信号，通信串口，输出信号 28 GPIO_10 UART2_CTS，发送清除信号，通信串口，输入信号 29 GPIO_11 UART2_TXD 30 GPIO_12 UART2_RXD 31 GPIO_13 复用信号 1：UART2_RTS 复用信号 2：UART0_LOG_TXD 32 GPIO_14 复用信号 1：UART2_CTS 复用信号 2：UART0_LOG_RXD 主要函数头文件#include &lt;stdio.h&gt; // 标准输入输出 #include &lt;unistd.h&gt; // POSIX标准接口 #include &quot;ohos_init.h&quot; // 用于初始化服务(services)和功能(features) #include &quot;cmsis_os2.h&quot; // CMSIS-RTOS API V2 #include &quot;iot_gpio.h&quot; // OpenHarmony API：IoT硬件设备操作接口-GPIO #include &quot;hi_io.h&quot; // 海思 Pegasus SDK：IoT硬件设备操作接口-IO #include &quot;hi_adc.h&quot; // 海思 Pegasus SDK：IoT硬件设备操作接口-ADC 函数1 串口初始化hi_u32 hi_uart_init(hi_uart_idx id, const hi_uart_attribute *param, const hi_uart_extra_attr *extra_attr); 备注：还需要初始化串口tx为输出模式加串口模式，rx为输入模式加串口模式 不清楚看openharmony用ubuntu编写GPIO id：表示串口号HI_UART_IDX_0, /**&lt; Physical port number 0.CNcomment:物理端口号0 CNend */ HI_UART_IDX_1, /**&lt; Physical port number 1.CNcomment:物理端口号1 CNend */ HI_UART_IDX_2, /**&lt; Physical port number 2.CNcomment:物理端口号2 CNend */ HI_UART_IDX_MAX /**&lt; Maximum physical port number, which cannot be used. CNcomment:物理端口号最大值， *param：指定串口属性这个为结构体 .baud_rate =填波特率比如115200 .data_bits = 数据位 HI_UART_DATA_BIT_5，HI_UART_DATA_BIT_6,HI_UART_DATA_BIT_7,HI_UART_DATA_BIT_8, .stop_bits = 停止位 HI_UART_STOP_BIT_1，HI_UART_STOP_BIT_2 .parity = 奇偶校验位 HI_UART_PARITY_NONE = 0, /**无校验CNend */ HI_UART_PARITY_ODD = 1, /**校验位，奇校验CNend */ HI_UART_PARITY_EVEN = 2, /**偶校验CNend */ *extra_attr：表示高级功能配置不常用一般直接填null，具体看文章末尾 返回值 成功0失败1函数2 串口读取hi_s32 hi_uart_read(hi_uart_idx id, hi_u8 *data, hi_u32 data_len); id：表示串口号HI_UART_IDX_0, /**&lt; Physical port number 0.CNcomment:物理端口号0 CNend */ HI_UART_IDX_1, /**&lt; Physical port number 1.CNcomment:物理端口号1 CNend */ HI_UART_IDX_2, /**&lt; Physical port number 2.CNcomment:物理端口号2 CNend */ HI_UART_IDX_MAX /**&lt; Maximum physical port number, which cannot be used. CNcomment:物理端口号最大值， *data：读取的数据保存数据的指针data_len：读取字节数的长度返回值 成功大于0 失败-1函数3 串口写hi_s32 hi_uart_write(hi_uart_idx id, const hi_u8 *data, hi_u32 data_len); id：表示串口号看上方 *data：写入的数据保存数据的指针data_len：写入字节数的长度返回值 成功大于0 失败-1函数4 关闭串口hi_u32 hi_uart_deinit(hi_uart_idx id); id：表示串口号看上方 补充：关于串口初始化高级功能 typedef struct &#123; hi_uart_fifo_line tx_fifo_line; hi_uart_fifo_line rx_fifo_line; hi_uart_fifo_line flow_fifo_line; hi_uart_block_state tx_block; hi_uart_block_state rx_block; hi_u16 tx_buf_size; hi_u16 rx_buf_size; hi_uart_dma_state tx_use_dma; hi_uart_dma_state rx_use_dma; &#125; hi_uart_extra_attr; 1、tx_fifo_line、rx_fifo_line、flow_fifo_line HI_FIFO_LINE_ONE_EIGHT = 1, /**&lt; FIFO interruption limitation, FIFO LINE = 1/8full. CNcomment:FIFO中断门限，FIFO LINE = 1/8full CNend */ HI_FIFO_LINE_ONE_QUARTER, /**&lt; FIFO interruption limitation, FIFO LINE = 1/4full. CNcomment:FIFO中断门限，FIFO LINE = 1/4full CNend */ HI_FIFO_LINE_HALF, /**&lt; FIFO interruption limitation, FIFO LINE = 1/2full. CNcomment:FIFO中断门限，FIFO LINE = 1/2full CNend */ HI_FIFO_LINE_THREE_QUARTERS, /**&lt; FIFO interruption limitation, FIFO LINE = 3/4full. CNcomment:FIFO中断门限，FIFO LINE = 3/4full CNend */ HI_FIFO_LINE_SEVEN_EIGHTS, /**&lt; FIFO interruption limitation, FIFO LINE = 7/8full. CNcomment:FIFO中断门限，FIFO LINE = 7/8full CNend */ 2、tx_block和rx_block HI_UART_BLOCK_STATE_NONE_BLOCK = 1, /**&lt; block mode, none-block. CNcomment:UART阻塞模式，非阻塞传输 CNend */ HI_UART_BLOCK_STATE_BLOCK, /**&lt; block mode, block. CNcomment:UART阻塞模式，阻塞传输 CNend */ 3、hi_u16 tx_buf_size;hi_u16 rx_buf_size; 设置缓冲区大小 4、tx_use_dma、rx_use_dma HI_UART_NONE_DMA = 1, /**&lt; None-DMA mode. CNcomment:DMA传输，不使用DMA CNend */ HI_UART_USE_DMA, /**&lt; DMA mode. CNcomment:DMA传输，使用DMA CNend */","tags":"openharmony ubuntu"},{"title":"openharmony南向开发教程","url":"/2024/12/10/openharmony南向开发教程/","text":"openharmony南向开发教程 openharmony用ubuntu源码下载 openharmony用ubuntu源码下载 openharmony用ubuntu图形化页面快速部署 openharmony用ubuntu图形化页面快速部署 openharmony用windows开发hi3861 openharmony用windows开发hi3861 openharmony用ubuntu编写helloworld openharmony用ubuntu编写helloworld openharmony烧录hi3861芯片 openharmony烧录hi3861芯片 openharmony用ubuntu编译产品解决方案 openharmony用ubuntu编译产品解决方案.md openharmony用ubuntu编写子系统模块 openharmony用ubuntu编写子系统模块 openharmony用ubuntu编写线程 openharmony用ubuntu编写线程 openharmony用ubuntu编写GPIO openharmony用ubuntu编写GPIO openharmony用ubuntu编写中断 openharmony用ubuntu编写中断 openharmony用ubuntu编写定时 openharmony用ubuntu编写定时 openharmony用ubuntu编写PWM openharmony用ubuntu编写PWM openharmony用ubuntu编写adc openharmony用ubuntu编写adc openharmony用ubuntu编写串口 openharmony用ubuntu编写串口 openharmony用ubuntu编写键值 openharmony用ubuntu编写键值","tags":"openharmony"},{"title":"arduino的菘果派e1程序烧录","url":"/2024/11/26/arduino的菘果派e1程序烧录/","text":"arduino的的菘果派e1程序烧录我们先安装上一章安装环境 arduino的菘果派e1环境搭建 我们打开arduino打开工具，选择开发板py32 arduino —→ py32f002a 这里是设置芯片的编译环境 设置时钟HSI是高速内部时钟，RC振荡器。 HSE是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源。 LSI是低速内部时钟，RC振荡器。 LSE是低速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源。 HCLK（High Clock，高时钟）也称为系统时钟 然后我们设置完编译环境后 设置串口 如果没设备请检查串口驱动 根据芯片手册PA3为RXPA2为TX也就说芯片接线图(RXTX为串口芯片) TX&lt;---&gt;PA3 RX&lt;---&gt;PA2 烧录（boot0为高电平）1先断电 2按住boot按键不放 3按住boot按键不放再插入串口芯片通电 4烧录完成后复位芯片 新版本烧录：1、先接好线序 V&lt;---&gt;5v或3.3 G&lt;---&gt;GND R&lt;---&gt;TX T&lt;---&gt;RX 进入下载模式 1先接线 2按下自锁开关锁定 3按一下rts按键 退出下载模式1、按下自锁开关释放 2、按一下rts按键 点击烧录芯片 出现下面图片代表烧录完毕 如果出现下图，代表进入下载模式失败请重新重复上面的步骤，或者检查串口接线是否正确 使用官方工具手动烧录我们先用arduino导出二进制烧录文件 导出的文件在工程&#x2F;build&#x2F;AirM2M.AirMCU.Air001Dev&#x2F;xxx.hex 我们打开PY32IspTool_x64.exe 我们先把芯片进去下载模式 1先断电 2按住boot按键不放 3按住boot按键不放再插入串口芯片通电 4烧录完成后复位芯片 备注：新版烧录看上方然后点击connext读取设备 读取成功 读取失败如果出现下图，代表进入下载模式失败请重新重复上面的步骤，或者检查串口接线是否正确或者关闭其他串口工具（包括arduion ide） 打开固件选择hex文件导出的文件在工程&#x2F;build&#x2F;AirM2M.AirMCU.Air001Dev&#x2F;xxx.hex 点击下载烧录成功后，点击重启芯片","tags":"arduino 菘果派e1 py32"},{"title":"arduino系列教程","url":"/2024/11/26/arduino系列教程/","text":"arduino系列教程arduinoIDE使用教程 arduinoIDE使用教程 arduino的GPIO输入输出 arduino的GPIO输入输出 arduino的中断 arduino的中断 arduino的定时 arduino的定时 arduino的pwm arduino的pwm arduino的adc arduino的adc arduino的串口通信 arduino的串口通信 arduino的IIC通信 arduino的IIC通信 arduino的spi通信 arduino的spi通信 arduino扩展库arduino的0.95寸oled arduino的oled arduino的DHT11温湿度传感器 arduino的DHT11 arduino芯片手册1、esp32 arduino的ESP32的环境搭建 arduino的ESP32的环境搭建 arduino基于ESP32基本信息 arduino基于ESP32基本信息 2、stm32 arduino基于stm32环境搭建 arduino基于stm32环境搭建 arduino基于stm32基本信息 arduino基于stm32基本信息 3、py32、air001 arduino的菘果派e1环境搭建 arduino的菘果派e1环境搭建 菘果派e1系列基本资料 菘果派e1系列基本资料 arduino的菘果派e1程序烧录 arduino的菘果派e1程序烧录","tags":"arduino 菘果派e1 py32"},{"title":"菘果派e1系列基本资料","url":"/2024/11/26/菘果派e1系列基本资料/","text":"基本信息官方手册下载：下载 菘果派e1采用PY32F002AF15P6TU作为核心主控芯片采用 32位ARM® Cortex® - M0+核心制作最高24MHz工作频率最大3Kbytes SRAM多达18个I&#x2F;O，均可作为外部中断1 x 12-bit ADC1个16bit高级控制定时器（TIM1）1个基本定时器（TIM16）1个串口1个iic1个spi 资料下载原理图： 引脚图： 芯片开发方法：arduino：环境搭建 arduino的菘果派e1环境搭建 芯片烧录 arduino的菘果派e1程序烧录 参考代码开发 arduino系列教程 KEIL：编写ing，前面的区域以后再来探索吧(绝对不是因为我蓝狗，:d)","tags":"arduino 菘果派e1 py32"},{"title":"arduino的菘果派e1环境搭建","url":"/2024/11/25/arduino的菘果派e1环境搭建/","text":"arduino的菘果派e1环境搭建arduino项目地址：https://github.com/py32duino/Arduino-PY32 在线部署：https://github.com/py32duino/Arduino-PY32/blob/master/package/package_py32_index.template.json 离线部署方法： 通过百度网盘分享的文件：py32链接：https://pan.baidu.com/s/1qa_a0Ipf9JV_FzTPYu4tVA?pwd=7r0z提取码：7r0z 打开hfs软件，把软件端口改8080 把hfs之外的文件全部拖入外里面 点击package_py32_index.json文件，复制上面的链接 hfs不要关闭 打开arduino ide软件(安装链接) 左上角文件点击首选项 在其他开发者管理器地址粘贴刚刚复制的链接 点击arduino开发版管理器(在软件的左边菜单处) 选择安装py32(注意版本不要修改，因为没准备其他版本的文件) 然后点安装Arduino就会自动安装了到此软件配置完成 注：如果新版本出现卡在某一处不动的情况，可以把hfs和arduino关掉再重新打开，然后重新安装。按照这个步骤多试几次就可以完成安装。 更新：菘果派兼容air001的arduino代码所以也可以安装air001的环境 https://arduino.luatos.com/package_air_cn_index.json海外用户使用：https://github.com/Air-duino/Arduino-pack-json-ci/releases/download/Nightly/package_air_index.json","tags":"arduino 菘果派e1 py32"},{"title":"openharmony用ubuntu编写PWM","url":"/2024/11/22/openharmony用ubuntu编写PWM/","text":"openharmony用ubuntu编写PWM代码下载 第一部分：代码结构1、我们需要先初始化GPIO为输出2、初始化PWM3、配置PWM 主要函数头文件#include &quot;iot_gpio.h&quot; // OpenHarmony HAL API：IoT硬件设备操作接口-GPIO #include &quot;iot_pwm.h&quot; // OpenHarmony HAL API：IoT硬件设备操作接口-PWM #include &quot;hi_io.h&quot; // 海思SDK API：IoT硬件设备操作接口-IO #include &quot;hi_pwm.h&quot; // 海思SDK API：IoT硬件设备操作接口-PWM 配置GPIO输出PWMhi_io_set_func(引脚,模式); 引脚：开发板上要用的GPIO引脚号模式：我们这边主要设置的pwm的模式具体哪些模式需要查询：&#x2F;&#x2F;鸿蒙路径&#x2F;device&#x2F;hisilicon&#x2F;hispark_pegasus&#x2F;sdk_liteos&#x2F;include&#x2F;hi_io.hhttps://github.com/HiW666/openharmony-code/blob/main/code/hi_io.h 设置pwmIoTPwmInit(pwm线程); pwm线程：根据上方函数模式里面配置的pwm比如是pwm1那么就填HI_PWM_PORT_PWM1pwmx那么就填HI_PWM_PORT_PWMx 输出pwmhi_pwm_start(pwm线程, ccr, 分辨率); pwm线程：根据上方函数模式里面配置的pwm比如是pwm1那么就填HI_PWM_PORT_PWM1pwmx那么就填HI_PWM_PORT_PWMxccr：设置占空比参数分辨率：设置占空比参数占用比：ccr&#x2F;分辨率 关闭pwmhi_pwm_stop(pwm线程); pwm线程：根据上方函数模式里面配置的pwm比如是pwm1那么就填HI_PWM_PORT_PWM1pwmx那么就填HI_PWM_PORT_PWMx pwm控制音频 hi_pwm_start(pwm线程, freqDivisor/2, freqDivisor); 占空比为百分之50freqDivisor为分倍频率freqDivisor&#x3D;时钟源频率&#x2F;音频表频率hi3861为4m&#x2F;频率 补充关于鸿蒙默认pwm没有开启鸿蒙路径&#x2F;device&#x2F;hisilicon&#x2F;hispark_pegasus&#x2F;sdk_liteos&#x2F;build&#x2F;config&#x2F;usr_config.mk找到pwm文件 修改为","tags":"openharmony ubuntu"},{"title":"arduino的adc","url":"/2024/11/21/arduino的adc/","text":"arduino的adcarduino支持adc，但是这个是和硬件绑定的需要芯片支持adc转换芯片，具体要查哪些引脚支持。 基准电压：基准电压一般就是单片机gpio推挽输出高电平的电压adc分辨率：手册一般会说支持xxxbit的adc，那么分辨率就是2的xxx次方（2^xxx） 拿esp32举例esp32最高支持12bit的adc那么最高分辨率就是2^12（2的12次方）也就是4096因为esp32输出电压是3.3，所以基准电压是3.3也就是能读取0到3.3之间的电压 arduino 官方支持10bit adc那么最高分辨率就是2^10（2的10次方）也就是1024因为arduino输出电压是5，所以基准电压是5也就是能读取0到5之间的电压 读取adc数字量analogRead(引脚); 参数 数据类型 作用 选项 引脚 int 支持adc的引脚io 单片机io 返回值 int 返回0到2的X次方（x就是adc位深比如10bit就是0到1024，12bit就是0到4096） 无 返回值：引脚的输入电压将在0V到3.3之间，模拟数字转换（adc）功能作用下，该输入电压将被映射到数值0-4096之间。（0V对应数值0， 3.3V对应4096）以上是esp32单片机的adc 读取adc电压float 电压 = 0; 电压 = analogRead(引脚) * (基准电压 / adc分辨率); 电压：读取的电压基准电压：基准电压一般就是单片机gpio推挽输出高电平的电压adc分辨率：手册一般会说支持xxxbit的adc，那么分辨率就是2的xxx次方（2^xxx） 参考： const int analogInPin = 4; // 定义模拟输入引脚 int sensorValue = 0; // 存储模拟输入的值 float voltage = 0; void setup() &#123; Serial.begin(9600); // 初始化串口通信 &#125; void loop() &#123; sensorValue = analogRead(analogInPin); // 读取模拟输入的值 voltage = sensorValue * (3.3 / 4096); // 将模拟输入的值转换为电压值 // 打印输出 Serial.print(&quot;sensor = &quot;); Serial.print(sensorValue); Serial.print(&quot;\\t vol = &quot;); Serial.print(voltage); Serial.println(&quot;V&quot;); delay(2); // 延迟2毫秒 &#125; &#x2F;&#x2F;4号脚输入0到3.3之间的电压","tags":"arduino esp32"},{"title":"arduino基于stm32基本信息","url":"/2024/11/21/arduino基于stm32基本信息/","text":"arduino基于stm32基本信息关于stm32在arduino io图可以选择PAX，PBX keil引脚方式或者直接使用arduino io：1，2，3，4。。。20，21等stm32f103c8t6 arduino工具烧录方式我们主要使用的工具1，选择芯片型号2，选择烧录工具 stlink烧录主要是就是用上面那三种要用stlink需要下载STM32CubeProgrammer注：只有官方正版stlink才行，非st芯片的stlink不行 官网其他网盘 串口烧录根据上面stm32引脚图 PA9 接 RX PA10 接 TX 把芯片调整boot0 为1boot1 为0然后按复位resrt按键就可以烧录 烧录完成后把芯片调整boot0 为0boot1 为0再按复位程序就能运行了 usb烧录首先我们要给stm32刷入特定固件固件下载：https://wwwe.lanzouq.com/iHCgi2fq13ad支持的芯片选择led电平具体看自己的开发板点进去选择ioled所在引脚我手上这个板子是在pc13低电平 我们打开STM32CubeProgrammer烧录固件我们还是先把芯片调整boot0 为1boot1 为0然后按复位resrt按键 打开STM32CubeProgrammer烧录固件先读取设备 选择打开固件修改地址烧录 烧录完成后把芯片调整boot0 为0boot1 为0 然后usb直接连接电脑led亮说明烧录完成选择usb烧录","tags":"stm32 arduino"},{"title":"openharmony用ubuntu编写adc","url":"/2024/11/11/openharmony用ubuntu编写adc/","text":"openharmony用ubuntu编写adc代码下载 第一部分：代码结构软件部分目录结构 adc_demo ├─ BUILD.gn └─voltage_buttons_thread.c 我们打开文件代码打开voltage_buttons_thread.c hi3861 ADC 通道有 7 个，其中 GPIO 可复用成 ADC 的通道如下： 6 GPIO_04 ADC1 17 GPIO_05 ADC2 19 GPIO_07 ADC3 27 GPIO_09 ADC4 29 GPIO_11 ADC5 30 GPIO_12 ADC0 31 GPIO_13 ADC6 主要函数头文件#include &lt;stdio.h&gt; // 标准输入输出 #include &lt;unistd.h&gt; // POSIX标准接口 #include &quot;ohos_init.h&quot; // 用于初始化服务(services)和功能(features) #include &quot;cmsis_os2.h&quot; // CMSIS-RTOS API V2 #include &quot;iot_gpio.h&quot; // OpenHarmony API：IoT硬件设备操作接口-GPIO #include &quot;hi_io.h&quot; // 海思 Pegasus SDK：IoT硬件设备操作接口-IO #include &quot;hi_adc.h&quot; // 海思 Pegasus SDK：IoT硬件设备操作接口-ADC 函数1 读取adcunsigned int hi_adc_read(WifiIotAdcChannelIndex channel, unsigned short *data, WifiIotAdcEquModelSel equModel, WifiIotAdcCurBais curBais, unsigned short rstCnt) channel：表示ADC通道 HI_ADC_CHANNEL_0, HI_ADC_CHANNEL_1, HI_ADC_CHANNEL_2, HI_ADC_CHANNEL_3, HI_ADC_CHANNEL_4, HI_ADC_CHANNEL_5, HI_ADC_CHANNEL_6, HI_ADC_CHANNEL_7, HI_ADC_CHANNEL_BUTT,//一共有8个通道 data：表示指向存储读取数据的地址的指针equModel：表示平均算法的次数HI_ADC_EQU_MODEL_1, /**&lt; 0：The average value is not used. CNcomment:1次平均，即不进行 平均 CNend */ HI_ADC_EQU_MODEL_2, /**&lt; 1：2-time average algorithm mode. CNcomment:2次平均算法模式 CNend */ HI_ADC_EQU_MODEL_4, /**&lt; 2：4-time average algorithm mode. CNcomment:4次平均算法模式 CNend */ HI_ADC_EQU_MODEL_8, /**&lt; 3：8-time average algorithm mode. CNcomment:8次平均算法模式 CNend */ HI_ADC_EQU_MODEL_BUTT curBais：表示模拟功率控制模式 HI_ADC_CUR_BAIS_DEFAULT, /**&lt; 0：Auto control. CNcomment:自动识别模式 */ HI_ADC_CUR_BAIS_AUTO, /**&lt; 1：Auto control. CNcomment:自动识别模式 */ HI_ADC_CUR_BAIS_1P8V, /**&lt; 2：Manual control, AVDD=1.8V. CNcomment:手动控制，AVDD=1.8V */ HI_ADC_CUR_BAIS_3P3V, /**&lt; 3：Manual control, AVDD=3.3V. CNcomment:手动控制，AVDD=3.3V */ HI_ADC_CUR_BAIS_BUTT, rstCnt：指示从重置到转换开始的时间计数。一次计数等于334纳秒。值的范围必须从0到0xFF返回值：错误码 错误HI_ERR_ADC_TIMEOUT 成功 HI_ERR_SUCCESS","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu编写中断","url":"/2024/11/09/openharmony用ubuntu编写中断/","text":"openharmony用ubuntu编写中断代码下载 第一部分：代码结构软件部分目录结构 gpio_input_demo ├─ BUILD.gn └─gpio_input_int.c 我们打开文件代码打开gpio_input_int.c 不同SOC芯片由于其GPIO控制器型号、参数、以及控制器驱动的不同，GPIO管脚号的换算方式不一样。 主要函数头文件#include &quot;iot_gpio.h&quot; // OpenHarmony HAL API：IoT硬件设备操作接口-GPIO #include &quot;hi_io.h&quot; // 海思Pegasus SDK API：IoT硬件设备操作接口-IO 注册中断函数IoTGpioRegisterIsrFunc(引脚,触发模式,触发方法,中断处理函数,NULL); 引脚：开发板上要用的GPIO引脚号 触发模式：电平触发：IOT_INT_TYPE_LEVEL&#x3D;&#x3D;0边沿触发触发：IOT_INT_TYPE_EDGE 触发方法：如果是电平触发的情况下：0为低电平触发，1为高电平触发如果是边沿触发的情况下：0为下降沿触发，1为上升沿触发参数IOT_GPIO_EDGE_FALL_LEVEL_LOW&#x3D;&#x3D;0，IOT_GPIO_EDGE_RISE_LEVEL_HIGH&#x3D;&#x3D;1 中断处理函数：如果创建的函数为 void XXX(){}那么就填XXX那么中断的时候就会执行XXX里面的代码 NULL：中断处理函数的参数","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu编写定时","url":"/2024/11/09/openharmony用ubuntu编写定时/","text":"openharmony用ubuntu编写中断代码下载 第一部分：代码结构软件部分目录结构 timer_demo ├─ BUILD.gn └─timer_once.c 我们打开文件代码打开timer_once.c hi3861默认10ms为一个tick 主要函数头文件#include &lt;stdio.h&gt; // 标准输入输出 #include &lt;unistd.h&gt; // POSIX标准接口 #include &quot;ohos_init.h&quot; // 用于初始化服务(services)和功能(features) #include &quot;cmsis_os2.h&quot; // CMSIS-RTOS API V2 创建定时osTimerNew(osTimerFunc_t func, osTimerType_t type, const osTimerAttr_t *attr); func：函数指针指向回调函数（时间到执行的函数）type：定时器类型，osTimerOnce表示单次定时器，ostimer周期表示周期性定时器argument：定时器回调函数的参数 不清楚填NULLattr：计时器属性 不清楚填NULL返回值：定时器ID 启动定时器，不能在中断服务调用该函数osStatus_t osTimerStart (osTimerId_t timer_id,uint32_t ticks) timer_id：定时器IDticks：时间滴答计时器的值返回值：0 - 成功，非0 - 失败 停止定时器osTimerStop(osTimerId_t timer_id) timer_id: 定时器id 删除定时器osStatus_t osTimerDelete (osTimerId_t timer_id) timer_id：定时器ID返回值：0 - 成功，非0 - 失败","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu编写GPIO","url":"/2024/11/08/openharmony用ubuntu编写GPIO/","text":"openharmony用ubuntu编写GPIO代码下载 第一部分：代码结构软件部分目录结构 gpio_input_demo ├─ BUILD.gn └─ gpio_input_get.c 我们打开文件代码打开gpio_input_get.c 不同SOC芯片由于其GPIO控制器型号、参数、以及控制器驱动的不同，GPIO管脚号的换算方式不一样。 工作流程 主要函数头文件#include &quot;iot_gpio.h&quot; // OpenHarmony HAL API：IoT硬件设备操作接口-GPIO #include &quot;hi_io.h&quot; // 海思Pegasus SDK API：IoT硬件设备操作接口-IO 初始化GPIOIoTGpioInit(引脚); 引脚：开发板上要用的GPIO引脚号返回值：成功：IOT_SUCCESS（0）失败：IOT_FAILURE（-1） 设置GPIO模式IoTGpioSetDir(引脚,GPIO方向);//1-输出 0-输入 引脚：开发板上要用的GPIO引脚号GPIO方向： 输出：IOT_GPIO_DIR_OUT&#x3D;&#x3D;1 输入： IOT_GPIO_DIR_IN &#x3D;&#x3D;0返回值：成功：IOT_SUCCESS（0）失败：IOT_FAILURE（-1） GPIO复用hi_io_set_func(引脚,模式); 引脚：开发板上要用的GPIO引脚号模式：有些GPIO还需要设置复用功能，可能默认不是普通GPIO模式。具体哪些模式需要查询：&#x2F;&#x2F;鸿蒙路径&#x2F;device&#x2F;hisilicon&#x2F;hispark_pegasus&#x2F;sdk_liteos&#x2F;include&#x2F;hi_io.h代码跳转返回值：成功：IOT_SUCCESS（0）失败：IOT_FAILURE（-1） GPIO输入模式hi_io_set_pull(引脚, 输入模式); 引脚：开发板上要用的GPIO引脚号输入模式：HI_IO_PULL_NONE, &#x2F;&lt; Disabled.CNcomment:无拉CNend&#x2F;&#x2F;浮空HI_IO_PULL_UP, &#x2F;&lt; Pull-up enabled.CNcomment:上拉CNend *&#x2F;HI_IO_PULL_DOWN, &#x2F;**&lt; Pull-down enabled.CNcomment:下拉CNend *&#x2F;HI_IO_PULL_MAX, &#x2F;**&lt; Invalid.CNcomment:无效值CNend *&#x2F; GPIO读取电平IoTGpioGetInputVal(引脚, &amp;value); 引脚：开发板上要用的GPIO引脚号value：接收读取电平值的指针，可以设置IotGpioValue valuevalue为1是高电平，0是低电平返回值：成功：IOT_SUCCESS（0）失败：IOT_FAILURE（-1） 系统延时usleep(us); // delay us osDelay(us);// delay us hi_udelay(us);// delay_us int32 us：延迟为微秒","tags":"openharmony ubuntu"},{"title":"arduino的串口通信","url":"/2024/11/07/arduino的串口通信/","text":"arduino的串口通信工程下载 arduino提供了非常强大的串口通信函数，这可能是我唯一觉得arduino的优点他可以使用简单的函数配置和使用串口与其他设备进行通信当然串口通信还是要看单片机是否有指定的IO也不是所有的IO都支持串口 arduino的串口是否接收到数据Serial.available() 该函数将会返回等待读取的数据字节数等待读取的数据字节数。返回值数据类型：int arduino的禁用串口Serial.end() 终止串行通讯，包括rx，tx可调用 Serial.begin()重新打开串行通讯。 arduino的查找串口是否有指定数据Serial.find(数据内容); 数据内容：被查找字符串。允许使用String或char类型。 返回值：如果接收到的数据内容一致就会返回真（不为0的数）否者就是假（0）bool类型 arduino的查找串口是否有指定数据带结束Serial.findUntil(开始执行数据内容, 终止的数据内容); 开始执行数据内容：允许使用String或char类型。如果串口读取到的和开始执行数据内容一致就会返回真，否者为假 终止的数据内容：用于设置终止函数执行的字符串信息。设备在读取数据时一旦读取到此终止字符串，将会结束函数执行并返回。可以用于开始和结束函数 arduino的串口数据提取整形类型的数据Serial.parseInt() 返回值：在输入信息中找到的整数数值。类型：long其他数据会丢失 arduino的串口数据提取浮点型类型的数据Serial.parseFloat() 返回值：在输入信息中找到浮点数值。类型：float arduino的串口初始化设置波特率Serial.begin(波特率); 波特率：设置电脑与Arduino进行串口通讯时的数据传输速率（每秒传输字节数）。可使用以下速率：300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200等你也可以根据你所使用的设备而设置其他传输速率。（数据类型： long） arduino的串口发送一个字节Serial.write(字节) Serial.write(字符串) Serial.write(字节数组, 长度) 字节：0x（xx）字符串：比如发送123就会变成0x49 0x50 0x51字节数组：创建数组，把字节存里面长度：发送多少的字节返回值：会返回发送的字节数。 arduino的串口发送数据Serial.print(数据, 模式); 数据：如果指定模式的情况下，默认以ASCII码形式发送Serial.print(数据) 模式：BIN (binary二进制)OCT (octal八进制)DEC (decimal十进制)HEX (hexadecimal十六进制)指定小数点的位数：输入具体的数字来指定多少位Serial.print(78, BIN) 发送 “1001110”Serial.print(78, OCT) 发送 “116”Serial.print(78, DEC) 发送 “78”Serial.print(78, HEX) 发送 “4E”Serial.println(1.23456, 0) 发送 “1”Serial.println(1.23456, 2) 发送 “1.23”Serial.println(1.23456, 4) 发送 “1.2346” 你可以用F()把待发送的字符串包装到flash存储器。例如：Serial.print(F(“Hello World”)) arduino的串口发送数据带换行Serial.println(数据, 模式) 具体参数不多说和上面的一样，只是多了换行 arduino的串口读取一个字节（非数据流）Serial.peek(); 读取一个字节的数据，如果没数据返回值为0，如果是一串数据的话，第一个数据读出后不会消失所以只能读取第一个数据read可以读取一串数据 arduino的串口读取字符串Serial.readString() 返回值：接收到的数据，类型为字符串。 arduino的串口读取字符串带终止Serial.readStringUntil(终止符); 终止符：终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。返回值：接收到的数据，类型为字符串。 arduino的串口读取一个字节（数据流）Serial.read() 返回值：设备没有接收到数据时，返回值为-1设备接收到数据时，返回值为接收到的数据流中的1个字符函数可用于从设备接收到数据中读取一个字节的数据。读取数据流，数据会放缓存里面，读取一个数据就会丢失一个数据，下一个数据就会替换上去 arduino的串口读取数据并且存储在数组中Serial.readBytes(变量/数组, 读取字节上限); 变量&#x2F;数组：用于存储读取到的信息。允许使用char或者byte类型的变量或数组。读取字节上限：指定的字节数量后就会停止运行。允许使用int类型 arduino的串口读取数据并且存储在数组中带停止Serial.readBytesUntil(终止字符, 变量/数组, 读取字节上限); 终止字符:用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符将会结束函数执行。允许使用char类型。变量&#x2F;数组：用于存储读取到的信息。允许使用char或者byte类型的变量或数组。读取字节上限：指定的字节数量后就会停止运行。允许使用int类型 arduino的查找串口设置缓存区Serial.flush() flush函数不具备清楚缓存效果当我们通过Serial.print或Serial.println来发送数据时，被发送的字符数据将会存储于开发板的“发送缓存”中。这么做的原因是开发板串行通讯速率不是很高，如果发送数据较多，发送时间会比较长。在没有使用flush函数的情况下，开发板不会等待所有“发送缓存”中数据都发送完毕再执行后续的程序内容。也就是说，开发板是在后台发送缓存中的数据。程序运行不受影响。相反的，在使用了flush函数的情况下，开发板是会等待所有“发送缓存”中数据都发送完毕以后，再执行后续的程序内容。 补充：清除接收缓存 void setup() &#123; Serial.begin(9600); &#125; void loop() &#123; clean ();//清除缓存的函数 &#125; void clean () &#123; // 以下while循环语句将会清除接收缓存内容。 // 具体工作原理是这样的。每当有数据输入接收缓存后， // 我们可以使用Serial.read()来读取接收缓存中的内容。 // 这时，如果我们对Serial.read()函数的返回值不加以任何利用 // 那么读取到的数据，也就是Serial.read()函数的返回值将会在 // 下一次执行Serial.read时所抛弃。利用while循环语句，我们可以 // 保证在接收缓存中有数据的时候，反复将串口接收缓存中的信息读取并抛弃。 // 从而达到清除接收缓存的目的。 while(Serial.available())&#123; Serial.println(&quot;Clearing Serial Incoming Buffer.&quot;); Serial.read(); &#125; // 当接收缓存为空时，Serial.read返回值为“-1” // 通过以下语句我们将看到无论我们是否通过串口监视器 // 输入信息，开发板的串口监视器会一直输出: // &quot;Incoming Buffer is Clear.&quot; // 这是因为接收缓存中的信息被以上while语句中的内容给清除掉了。 if (Serial.read() == -1)&#123; Serial.println(&quot;Incoming Buffer is Clear.&quot;); &#125; &#125; 使用方法：1、Serial.begin(波特率);先配置波特率2、 Serial.print(数据, 模式);发送3、Serial.read();读取 如果要使用多个串口Serialx.begin();x不填就是默认UART0，1就是UART1比如Serial1.begin()就是使用UART1Serial2.begin()就是使用UART2","tags":"arduino esp32"},{"title":"arduino的音谱文件","url":"/2024/11/06/arduino的音谱文件/","text":"arduino的音谱文件 //pitches.h #define NOTE_B0 31 #define NOTE_C1 33 #define NOTE_CS1 35 #define NOTE_D1 37 #define NOTE_DS1 39 #define NOTE_E1 41 #define NOTE_F1 44 #define NOTE_FS1 46 #define NOTE_G1 49 #define NOTE_GS1 52 #define NOTE_A1 55 #define NOTE_AS1 58 #define NOTE_B1 62 #define NOTE_C2 65 #define NOTE_CS2 69 #define NOTE_D2 73 #define NOTE_DS2 78 #define NOTE_E2 82 #define NOTE_F2 87 #define NOTE_FS2 93 #define NOTE_G2 98 #define NOTE_GS2 104 #define NOTE_A2 110 #define NOTE_AS2 117 #define NOTE_B2 123 #define NOTE_C3 131 #define NOTE_CS3 139 #define NOTE_D3 147 #define NOTE_DS3 156 #define NOTE_E3 165 #define NOTE_F3 175 #define NOTE_FS3 185 #define NOTE_G3 196 #define NOTE_GS3 208 #define NOTE_A3 220 #define NOTE_AS3 233 #define NOTE_B3 247 #define NOTE_C4 262 #define NOTE_CS4 277 #define NOTE_D4 294 #define NOTE_DS4 311 #define NOTE_E4 330 #define NOTE_F4 349 #define NOTE_FS4 370 #define NOTE_G4 392 #define NOTE_GS4 415 #define NOTE_A4 440 #define NOTE_AS4 466 #define NOTE_B4 494 #define NOTE_C5 523 #define NOTE_CS5 554 #define NOTE_D5 587 #define NOTE_DS5 622 #define NOTE_E5 659 #define NOTE_F5 698 #define NOTE_FS5 740 #define NOTE_G5 784 #define NOTE_GS5 831 #define NOTE_A5 880 #define NOTE_AS5 932 #define NOTE_B5 988 #define NOTE_C6 1047 #define NOTE_CS6 1109 #define NOTE_D6 1175 #define NOTE_DS6 1245 #define NOTE_E6 1319 #define NOTE_F6 1397 #define NOTE_FS6 1480 #define NOTE_G6 1568 #define NOTE_GS6 1661 #define NOTE_A6 1760 #define NOTE_AS6 1865 #define NOTE_B6 1976 #define NOTE_C7 2093 #define NOTE_CS7 2217 #define NOTE_D7 2349 #define NOTE_DS7 2489 #define NOTE_E7 2637 #define NOTE_F7 2794 #define NOTE_FS7 2960 #define NOTE_G7 3136 #define NOTE_GS7 3322 #define NOTE_A7 3520 #define NOTE_AS7 3729 #define NOTE_B7 3951 #define NOTE_C8 4186 #define NOTE_CS8 4435 #define NOTE_D8 4699 #define NOTE_DS8 4978","tags":"arduino esp32"},{"title":"arduino的定时","url":"/2024/11/06/arduino的定时/","text":"arduino的定时工程下载 关于arduino定时的这里介绍的主要是软件定时的方法和一般单片机的硬件定时不同的是，如果在中断函数里面arduino的定时是无效的 Arduino开机后运行的时间millis() 参数 数据类型 作用 选项 返回值 unsigned long 读取单片机启动到现在的运行了多少ms 无 该时间长度单位是毫秒,最长可记录接近50天左右的时间。如果超出记录时间上限，记录将从0重新开始。实际读取为unsigned long整数所以最大为4294967295毫秒计算方法：秒&#x3D;millis()&#x2F;1000分钟&#x3D;millis()&#x2F;1000&#x2F;60小时&#x3D;millis()&#x2F;1000&#x2F;60&#x2F;60天&#x3D;millis()&#x2F;1000&#x2F;60&#x2F;60&#x2F;60 micros() 参数 数据类型 作用 选项 返回值 unsigned long 读取单片机启动到现在的运行了多少us 无 和上面函数一样也是unsigned long整数但是这个是微秒所以最大为4294967295毫秒也就是最大记录70分钟左右微秒&#x3D;millis()&#x2F;1000秒&#x3D;millis()&#x2F;1000&#x2F;60分钟&#x3D;millis()&#x2F;1000&#x2F;60&#x2F;60 函数使用1、获取时间 millis()%时间 可以获取时，分钟，秒 2、可以记录下两次间隔的时间 unsigned long t1,t2,t3; void setup() &#123; &#125; void loop() &#123; t1=millis();//记录第一次时间 //一段时间后。。。 t2=millis();//记录第二次 t3=time(t1,t2);//计算差t3读取差 &#125; unsigned long time (unsigned long time1,unsigned long time2) &#123; unsigned long time3; if(time2-time1&gt;=0) &#123; time3=time2-time1;//两个时间差 return time3; &#125;else if (time2-time1&lt;0) &#123; time3=4294967295-time1+time2;//防止溢出 return time3; &#125; &#125; 3、定时延迟 可以同时进行其他操作不会影响到其他程序运行 unsigned long previousBlinkTime; int blinkInterval = xxx; //设置延迟xxx执行程序 void setup() &#123; &#125; void loop() &#123; unsigned long currentMillis = millis(); // 获取当前时间 millisBlink(currentMillis);//调用函数 &#125; void millisBlink(unsigned long currentTime) &#123; //检查是否到达时间间隔 if (currentTime - previousBlinkTime &gt;= blinkInterval) &#123; //如果时间间隔达到 //执行代码区 //执行代码区 previousBlinkTime = currentTime; // 将检查时间复位 &#125; else if (currentTime - previousBlinkTime &lt;= 0) &#123; // 如果millis时间溢出 previousBlinkTime = currentTime; &#125; &#125;","tags":"arduino esp32"},{"title":"arduino的pwm","url":"/2024/11/06/arduino的pwm/","text":"arduino的pwm工程下载 理论来说arduino的pwm输出并不是使用到了内部的定时器所以，某些情况下面还是会发生冲突。而且，最大的问题是不能改变频率和占空比 arduino的pwm函数analogWrite(引脚, PWM占空比); 参数 数据类型 作用 选项 引脚 int 单片机支持pwm输出的IO 单片机io PWM占空比 int 输出的pwm占空比就是xxx&#x2F;255 0到255之间 返回值 无 无 无 arduino的pwm发出特定频率声音tone(引脚, 发声频率, 发声时长) 参数 数据类型 作用 选项 引脚 int 单片机支持pwm输出的IO 单片机io 发声频率 int 单位为赫兹 int 发声时长 int 单位为微秒 int 返回值 无 无 无 备注：1、使用tone()函数时可能会影响引脚3和引脚11的PWM信号输出2、如果你想要使用不同的引脚产生不同的声音音调，每一次更换发声引脚以前都要使用noTone函数停止上一个引脚发声。Arduino是不支持两个引脚同时发声的。3、arduino的音谱文件 arduino关闭pwm发出特定频率声音noTone(引脚) 参数 数据类型 作用 选项 引脚 int 单片机支持pwm输出的IO 单片机io 返回值 无 无 无 使用方法1、先初始io为输出模式2、使用pwm函数 参考代码案例int ledPin = 2;//led int intvalue,value; void setup() &#123; pinMode(ledPin,OUTPUT);//初始化led为输出模式 &#125; void loop()&#123; for (intvalue = 0 ; value &lt; 255; value=value+1)&#123;//执行亮度增加 analogWrite(ledPin, value);//改变占用比 delay(5); &#125; for (intvalue = 255; value &gt;0; value=value-1)&#123;//执行亮度减少 analogWrite(ledPin, value);//改变占用比 delay(5); &#125; &#125;","tags":"arduino esp32"},{"title":"arduino的中断","url":"/2024/11/05/arduino的中断/","text":"arduino的中断工程下载 arduino是支持中断的但是缺点的目前的arduino是不支持设置中断优先级（目前记录为2.3.3版本）而且在中断函数中delay()函数是不工作的，而且millis()函数返回值也不再增长。(delayMicroseconds()函数除外)运行期间Arduino开发板接收到的串口数据也可能丢失 arduino的中断函数初始化attachInterrupt(中断号,中断函数, 中断模式); 中断号：中断号不是引脚号，要具体查arduino开发板哪些引脚支持中断在ESP32中除了34-39都可以支持中断 中断函数：使用void xxx创建函数函数不能有返回值，所以应尽量在中断服务程序中使用全局变量这里写函数名即可（比如函数xxx()只用写xxx即可） 中断模式：arduino通用提供了5种模式选择LOW （0x0）： 当引脚为低电平时触发中断服务程序DISABLED（0x00）：失能模式,禁用中断CHANGE （0x03）： 当引脚电平发生变化时触发中断服务程序，边沿触发RISING （0x01）： 当引脚电平由低电平变为高电平时触发中断服务程序，上升沿触发FALLING （0x02）： 当引脚电平由高电平变为低电平时触发中断服务程序，下降沿触发arduino之外的中断模式少部分芯片支持比如esp32 ONLOW （0x04）：低电平触发ONHIGH （0x05）：高电平触发ONLOW_WE （0x0C）：带消抖低电平触发ONHIGH_WE （0x0D）：带消抖高电平触发 禁用中断detachInterrupt(中断号); 中断号：中断号不全是引脚号，要具体查arduino开发板哪些引脚支持中断在ESP32中除了34-39都可以支持中断 使用方法1、先初始化IO为输入（具体什么输入模式看情况）2、初始化中断3、写中断函数 代码参考： int state=LOW; void setup() &#123; pinMode(2, OUTPUT);//初始化led pinMode(13, INPUT_PULLUP); //初始化中断io attachInterrupt(13, abc, FALLING);//初始化中断 &#125; void loop() &#123; digitalWrite(2, state);//显示led &#125; void abc()//中断函数 &#123; delayMicroseconds(50000);//延迟50ms消抖 if (digitalRead(13)==0) &#123; state = !state;//翻转led &#125; &#125; //2脚输出接led //13脚按键接地 按键按键就会翻转led","tags":"arduino esp32"},{"title":"arduinoIDE使用教程","url":"/2024/11/04/arduinoIDE使用教程/","text":"arduino IDE使用教程这里为开发板管理器可以搜索官方的开发板 点击文件，首选项这里可以添加第三方芯片 这里选择要编译的芯片左边栏为选择芯片右边为选择芯片的串口位置arduino一般为串口烧录芯片白色为代码区主要使用C或者CPP编写相对是main函数位置黑色为监控区，主要查看代码是否烧录成功是否编译通过以及各种重要信息这里为arduino库相对是添加C语言的头文件他是联网下载，不用自己手动添加到代码这里是手动添加库的地方 arduino代码结构 //A区 //arduino库的位置一般为xxx.h //还有宏定义 void setup() &#123; //B区 //相对是初始化 //就是只执行一次的代码 &#125; void loop() &#123; //C区 //主要运行的代码 //这里是重复运行的 &#125; 相当C语言 //A区 void main&#123; //B区 while(1) &#123; //C区 &#125; &#125; 所以arduino的优势相当是让你专注于写main函数部分其他部分交给社区开发者，更容易上手","tags":"arduino"},{"title":"arduino的GPIO输入输出","url":"/2024/11/03/arduino的GPIO输入输出/","text":"arduino的GPIO输入输出工程下载 我们使用ESP32 wroom32e举例我们先看查自己开发板的IO图ESP32系列的 arduino基于ESP32基本信息 基本arduino入门 arduinoIDE使用教程 arduino的GPIO初始化引脚初始化 pinMode(引脚号, 选择引脚模式); 参数 数据类型 作用 选项 引脚号 int 指定引脚初始化 自己查芯片手册 选择引脚模式 int 指定引脚模式 OUTPUT（0x03）：输出模式INPUT（0x01）：输入模式PULLUP（0x04）:上拉INPUT_PULLUP（0x05）：上拉输入PULLDOWN（0x08）：下拉INPUT_PULLDOWN（0x09）：下拉输入OPEN_DRAIN（0x10）：开漏OUTPUT_OPEN_DRAIN（0x13）：开漏输出ANALOG（0xC0）：模拟输入 返回值 无 无 无 引脚模式： arduino的GPIO输出digitalWrite(引脚号, 模式); 参数 数据类型 作用 选项 引脚号 int 指定引脚初输出 自己查芯片手册 引脚模式 int 选择输出高低电平 HIGH（0x1）：输出高电平LOW（0x0）：输出低电平 返回值 无 无 无 arduino的GPIO输入digitalRead(引脚号); 参数 数据类型 作用 选项 引脚号 int 指定引脚初输出 自己查芯片手册 返回值 int 读取的电平结果 0x1就是高0x0就是低 延迟毫秒delay(数值); 参数 数据类型 作用 选项 数值 unsigned long 输入一个大于0的整数是延迟多少毫米(1秒&#x3D;1000毫秒) unsigned long 延迟微秒delayMicroseconds(); 参数 数据类型 作用 选项 数值 unsigned long 输入一个大于0的整数是延迟多少微秒(1秒&#x3D;1000微秒) unsigned long 返回值 无 无 无 GPIO使用方法：1，我们先初始化引脚2，输出或者输入引脚 参考代码： int LED = 2;//led引脚2号 int key = 13;//按键13号脚 void setup() &#123; pinMode(LED, OUTPUT);//初始化 pinMode(key, INPUT_PULLUP);//初始化 digitalWrite(LED, LOW); //2脚低电平 &#125; void loop() &#123; if(digitalRead(key)==0)//读取电平 &#123; digitalWrite(LED, HIGH); //电平拉高灯亮 delay(50);//延迟 &#125; digitalWrite(LED, LOW); //低电平 &#125; //13脚接按键，按键连接低电平 //按下按键灯会亮 效果图：","tags":"arduino esp32"},{"title":"arduino的ESP32的环境搭建","url":"/2024/11/02/arduino的ESP32的环境搭建/","text":"arduino的ESP32的环境搭建我们直接下载安装包完整下载 我们直接点击离线安装包就可以自动安装了 安装动画 可能有时候可能还要手动补充安装打开arduino ide打开开发板管理面板如果安装过其他版本的esp package，请先删除，再使用本安装包。删除方法：文件管理器地址栏输入 %LOCALAPPDATA%&#x2F;Arduino15&#x2F;packages，回车进入，然后删除掉其中的esp32文件夹 PS：如果要添加多个开发板地址，请点后面的按钮，然后一行一个 备注：esp32c3 烧录请选择烧录时选择flash模式为DIO，默认是选择QIO模式的，如果是选择QIO模式烧录了程序，板子是无限重启，串口会不断打印系统重启信息。这一点切记！！！","tags":"arduino esp32"},{"title":"arduino基于ESP32基本信息","url":"/2024/11/01/arduino基于ESP32基本信息/","text":"arduino基于ESP32基本信息ESP32 c6 IO图 ESP32 wroom 32e IO图 ESP32 c3 IO图 合宙ESP32C3-CORE开发板 ESP32C6 测试代码测试代码 #include &lt;Adafruit_NeoPixel.h&gt; constexpr uint8_t LED_PIN = 8; constexpr uint8_t NUM_LEDS = 1; Adafruit_NeoPixel rgbLed(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800); struct RGB &#123; uint8_t r, g, b; &#125;; constexpr RGB COLOR_OFF = &#123;0, 0, 0&#125;; // ...Feel free to add more colors here... constexpr RGB CUSTOM_COLOR = &#123;255, 0, 255&#125;; void setup() &#123; rgbLed.begin(); rgbLed.show(); &#125; void setColor(const RGB&amp; color) &#123; rgbLed.setPixelColor(0, rgbLed.Color(color.r, color.g, color.b)); rgbLed.show(); &#125; void loop() &#123; setColor(CUSTOM_COLOR); delay(500); setColor(COLOR_OFF); delay(500); &#125; 效果 ESP32wroom 32e 测试代码 const int LEDA = 2; void setup() &#123; pinMode(LEDA, OUTPUT); &#125; void loop() &#123; digitalWrite(LEDA, HIGH); // turn the LED on (HIGH is the voltage level) delay(500); // digitalWrite(LEDA, LOW); // turn the LED off by making the voltage LOW delay(500); // &#125; 效果 led闪烁","tags":"arduino esp32"},{"title":"openharmony用ubuntu编写线程","url":"/2024/11/01/openharmony用ubuntu编写线程/","text":"openharmony用ubuntu编写线程完整代码 第一部分：代码结构软件部分目录结构 thread_demo ├─ BUILD.gn ├─ thread_basic.c └─ thread.c 我们打开文件代码打开thread_basic.c 编译后会看到效果可以看到是一直增加的 主要函数头文件// POSIX标准接口 #include &lt;unistd.h&gt; // 用于初始化服务(services)和功能(features) #include &quot;ohos_init.h&quot; // CMSIS-RTOS API V2 // 是OpenHarmony的LiteOS_m内核与应用程序之间的抽象层。（LiteOS_m内核基于Cortex M系列芯片） // 提供标准接口，便于应用程序移植来OpenHarmony，或者移植到其他支持CMSIS-RTOS API V2的系统。 // 头文件：kernel/liteos_m/kal/cmsis/cmsis_os2.h // 源文件：kernel/liteos_m/kal/cmsis/cmsis_liteos2.c #include &quot;cmsis_os2.h&quot; 创建一个线程，并将其加入活跃线程组中osThreadNew((osThreadFunc_t)threadMain, NULL, &amp;attr) osThreadId_t osThreadNew(osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) &#x2F;&#x2F; func 线程要运行的函数&#x2F;&#x2F; argument 指针，指向传递给线程函数的参数（可以是”xxxx”的形式）&#x2F;&#x2F; attr 线程属性(使用结构体)&#x2F;&#x2F; 注意：不能在中断服务调用该函数 //关于attr结构体 // 定义线程属性 osThreadAttr_t attr; // 线程名 attr.name = &quot;rtosv2_thread_main&quot;; // 线程属性位 attr.attr_bits = 0U; // 线程控制块的内存初始地址，默认为系统自动分配 attr.cb_mem = NULL; // 线程控制块的内存大小 attr.cb_size = 0U; // 线程栈的内存初始地址，默认为系统自动分配 attr.stack_mem = NULL; // 线程栈的内存大小 attr.stack_size = 1024; // 线程优先级，9(highest) - 38(lowest priority)，默认为osPriorityNormal // 位置：kernel\\liteos_m\\kal\\cmsis\\cmsis_os2.h attr.priority = osPriorityNormal; 如果osThreadNew((osThreadFunc_t)threadMain, NULL, &amp;attr)&#x3D;&#x3D;NULL说明函数运行失败 读取当前线程IDosThreadGetId(); 参考用法 osThreadId_t tid = osThreadGetId(); printf(&quot;thread id: %p\\r\\n&quot;, tid); 读取当前线程名字osThreadGetName(tid) tid为线程ID可以用上面的方法获取ID 得到线程的状态osThreadGetState(tid) tid为线程ID可以用上面的方法获取ID 设置线程的优先级osThreadSetPriority(tid, osPriorityNormal4); tid为线程ID可以用上面的方法获取IDosPriorityNormal4为优先级优先级有 osPriorityNormal = 24, osPriorityNormal1 = 24+1, osPriorityNormal2 = 24+2, osPriorityNormal3 = 24+3, osPriorityNormal4 = 24+4, osPriorityNormal5 = 24+5, osPriorityNormal6 = 24+6, osPriorityNormal7 = 24+7, 读取线程的优先级osThreadGetPriority(tid); tid为线程ID可以用上面的方法获取ID 挂起线程osThreadSuspend(tid); 也可以读取挂起情况 恢复线程osThreadResume(tid); 得到线程的栈空间大小osThreadGetStackSize(tid); 得到线程的未使用的栈空间大小osThreadGetStackSpace(tid); 获取活跃线程数osThreadGetCount(); 终止线程osThreadTerminate(tid);","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu编写键值","url":"/2024/10/22/openharmony用ubuntu编写键值/","text":"openharmony用ubuntu编写键值完整下载 第一部分：代码结构软件部分目录结构 kvstore_demo ├─ BUILD.gn └─ kvstore.c 我们打开文件代码打开kvstore.c 编译后会看到效果（第一次可能是显示0，第二次复位就好了） 主要函数注册键值并且能获取状态UtilsGetValue(按键名字, 按键内容, 字体长度); 函数为读写函数按键名字用char写按键内容char写字体长度int写可以用int去读读取到操作成功则返回0；参数错误返回-9；其他情况返回-1 const char *key = &quot;name&quot;; char value[32] = &#123;0&#125;; int retGet = UtilsGetValue(key, value, 32);//读取键值的运行情况 //读取到操作成功则返回0；参数错误返回-9；其他情况返回-1 修改键值的内容UtilsSetValue(按键名字, 按键内容); 函数为读写函数这两个变量和前面一样可以用int去读读取到操作成功则返回0；参数错误返回-9；其他情况返回-1 if (retGet &lt; 0)//前面的读取参数情况 &#123; // 定义要添加的值 const char *valueToWrite = &quot;OpenHarmony&quot;; // UtilsSetValue：在文件系统或cache中添加或更新指定键的值 // 操作成功则返回0；参数错误返回-9；其他情况返回-1 int retSet = UtilsSetValue(key, valueToWrite);//写入键值 printf(&quot;SetValue, result = %d\\n&quot;, retSet);//打印键值 &#125; else //如果大于0就说明有错误，打印错误代码 &#123; printf(&quot;GetValue, result = %d, value = %s\\n&quot;, retGet, value); &#125;","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu编译产品解决方案.md","url":"/2024/10/14/openharmony用ubuntu编译产品解决方案/","text":"openharmony用ubuntu编译产品解决方案 vendor └── binging # 产品解决方案厂商 ├── binging # 产品名称 │ ├── hals # 产品解决方案OS适配 │ ├── BUILD.gn # 产品编译脚本 │ └── config.json # 产品配置文件 └── ...... 产品解决方案处于vendor目录下我们可以自己创建一个文件夹这个文件夹相当是厂商的名字假设我们的厂商是binging 然后我们开发了一个产品叫hibinging我们就在binging的文件夹下面创建hibinging 然后我们在创建两个文件 ├── BUILD.gn # 产品编译脚本 └── config.json # 产品配置文件 BUILD.gn文件编写 group(&quot;hibinging&quot;) &#123; &#125; 因为BUILD.gn文件在hibinging这个文件夹下面所以填hibinging config.json文件编写我们先分两个部分看 &quot;product_name&quot;: &quot;产品名称&quot;, &quot;ohos_version&quot;: &quot;鸿蒙版本&quot;, &quot;device_company&quot;: &quot;芯片厂商&quot;, &quot;board&quot;: &quot;开发板名称&quot;, &quot;kernel_type&quot;: &quot;选择的内核类型&quot;, &quot;kernel_version&quot;: &quot;选择的内核版本&quot;, 鸿蒙的内核有liteos_m,liteos_a,linux等然后下半部分就能编写子系统 &quot;subsystems&quot;: [ &#123; &quot;subsystem&quot;: &quot;子系统名称&quot;, &quot;components&quot;: [ &#123; &quot;component&quot;: &quot;子系统模块1&quot;, &quot;features&quot;:[] &#125;, &#123; &quot;component&quot;: &quot;子系统模块2&quot;, &quot;features&quot;:[] &#125; ...... ] &#125; ...... ] 不清楚子系统的可以跳转到下方 openharmony用ubuntu编写子系统模块","tags":"openharmony ubuntu"},{"title":"openharmony烧录hi3861芯片","url":"/2024/09/26/openharmony烧录hi3861芯片/","text":"工具下载https://wwwe.lanzouq.com/b007sxt37e密码:1eis首先导出编译默认输出的文件为Hi3861_wifiiot_app_allinone.bin&#x2F;&#x2F;鸿蒙根目录&#x2F;out&#x2F;wifiiot_hispark_pegasus&#x2F;Hi3861_wifiiot_app_allinone.bin将其拷到windows系统 然后打开HiBurn.exe我们先设置串口速度最高可以2000000再高就容易丢包了点确定保存记得勾选auto burn然后插入开发板，选择串口设备如果没有就安装CH340驱动如果还是不行就重启软件点击connect开始烧录按下芯片复位键就开始烧录了烧录完成后，记得关闭软件，不然再次按复位键会重复烧录然后打开MobaXterm点击session按照图片设置按下回车就可以看到芯片通信了","tags":"openharmony"},{"title":"openharmony用ubuntu编写子系统模块","url":"/2024/09/24/openharmony用ubuntu编写子系统模块/","text":"openharmony用ubuntu编写子系统模块在鸿蒙里面系统由很多的子系统组成子系统里面又可以由很多的模块组成在构建系统的时候可以选择只调用部分的子系统或者部分模块 （类似C语言里面的函数）我们可以在&#x2F;&#x2F;鸿蒙根目录&#x2F;build&#x2F;subsystem_config.json查看有哪些的子系统 &quot;子系统名&quot;: &#123; &quot;path&quot;: &quot;子系统路径&quot;, &quot;name&quot;: &quot;子系统名&quot;, &#125;, 为子系统添加模块假设我们要为applications子系统创建名为abc的模块我们先去&#x2F;&#x2F;鸿蒙根目录&#x2F;build&#x2F;subsystem_config.json找到applications子系统的路径 然后我们打开&#x2F;&#x2F;鸿蒙根目录&#x2F;applications&#x2F;standard在里面创建abc的文件夹 按照openharmony用ubuntu编写helloworld的方法添加 abc ├─ BUILD.gn └─ hello ├─ BUILD.gn └─ hello.c 如果不理解直接下载下面的文件拷进adc里面自己理解https://wwwe.lanzouq.com/iSIof2atjf8j密码:41nt 然后把模块关联进applications我们在&#x2F;&#x2F;鸿蒙根目录&#x2F;build&#x2F;lite&#x2F;components&#x2F;下面可以看到applications.json文件在下一个模块下方添加新的模块代码 &#123; &quot;component&quot;: &quot;hello&quot;, &quot;description&quot;: &quot; &quot;, &quot;optional&quot;: &quot;true&quot;, &quot;dirs&quot;: [ &quot;applications/sample/abc&quot; ], &quot;targets&quot;: [ &quot;//applications/sample/abc&quot; ], &quot;rom&quot;: &quot;&quot;, &quot;ram&quot;: &quot;&quot;, &quot;output&quot;: [], &quot;adapted_board&quot;: [ &quot;hi3861v100&quot; ], &quot;adapted_kernel&quot;: [ &quot;liteos_m&quot; ], &quot;features&quot;: [], &quot;deps&quot;: &#123; &quot;components&quot;: [ &quot;utils_base&quot; ] &#125; &#125; 如果是最后一个模块前往不要加 “，” 然后修改编译配置文件备注： 如果芯片不同记得找到自己编译配置文件 vendor下面是第一个路径芯片品牌，再进去才是芯片编译方案 编译文件都是config.json （只是拿hi3861举例）打开&#x2F;&#x2F;鸿蒙根目录&#x2F;vendor&#x2F;hisilicon&#x2F;hispark_pegasus&#x2F;config.json找到applications的子系统在下面修改为添加新的模块 &#123; &quot;subsystem&quot;: &quot;applications&quot;, &quot;components&quot;: [ &#123; &quot;component&quot;: &quot;wifi_iot_sample_app&quot;, &quot;features&quot;:[] &#125;, &#123; &quot;component&quot;: &quot;hello&quot;, &quot;features&quot;:[] &#125; ] &#125;, 最后保存编译即可openharmony烧录hi3861芯片","tags":"openharmony ubuntu"},{"title":"unityc#代码入门","url":"/2024/09/19/unityc#代码入门/","text":"debug终端打印https://docs.unity.cn/cn/2019.4/ScriptReference/Debug.html Debug.Log(&quot;XXX&quot;); XXX为输出的文字I Input输入https://docs.unity.cn/cn/2019.4/ScriptReference/Input.html#:~:text=%E8%AE%BF%E9%97%AE%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F Input.GetKey(KeyCode.X); X为检查输入的按键其中X要大写","tags":"unity c#"},{"title":"openharmony用ubuntu编写helloworld","url":"/2024/09/13/openharmony用ubuntu编写helloworld/","text":"openharmony用ubuntu编写helloworld上一期环境安装 openharmony用ubuntu源码下载 openharmony用ubuntu图形化页面快速部署 第一部分：介绍目录结构（看不懂的请直接拉到下面实践部分跟着复刻，这里是理论讲解） 软件部分目录结构 app ├─ BUILD.gn └─ 目标文件夹1 ├─ BUILD.gn └─ xxxx.c └─ 目标文件夹2 ├─ BUILD.gn └─ xxxx.c ..... 首先打开&#x2F;&#x2F;鸿蒙根目录&#x2F;applications&#x2F;sample&#x2F;wifi-iot&#x2F;app&#x2F; 找到 BUILD.gn的文件 (不要问我为什么拿window系统演示实际操作要在ubuntu里面) 我们打开文件 只有红框里面是函数，其他的#号开头的都是注释 文件有两个部分组成 其中features 的部分可以用 “:” 来增加要参与编译的文件夹介绍完之后打开目标文件夹介绍目标文件夹下的BUILD.gn文件 只有红框里面是函数，其他的#号开头的都是注释 该函数文件由三部分内容构成，目标、源文件、头文件路径。 目标：当前BUILD.gn文件所在的文件夹源文件：写C或者CPP代码文件头文件：C或CPP调用的库文件 第二部分：实践了解之后 我们在&#x2F;&#x2F;鸿蒙根目录&#x2F;applications&#x2F;sample&#x2F;wifi-iot&#x2F;app&#x2F; 目录下面创建 hello的文件夹 在hello的文件夹下面创建hello.cBUILD.gn这两个文件然后先打开hello.c文件里面编写 #include &lt;stdio.h&gt; #include &quot;ohos_init.h&quot; void Hello_World(void) &#123; printf(&quot;this is a test demo \\r\\n Hello World!\\r\\n&quot;); &#125; SYS_RUN(Hello_World); 也可以使用APP_FEATURE_INIT来实现， APP_FEATURE_INIT是OpenHarmony启动恢复模块接口，该接口用来启动业务。 效果是一样的。（APP_FEATURE_INIT和SYS_RUN定义都在ohos_init.h）文件中。 然后保存文件 再编写BUILD.gn文件 static_library(&quot;hello&quot;) &#123; sources = [ &quot;hello.c&quot;] include_dirs = [ &quot;//utils/native/lite/include&quot;] &#125; 然后回到&#x2F;&#x2F;鸿蒙根目录&#x2F;applications&#x2F;sample&#x2F;wifi-iot&#x2F;app&#x2F;修改app目录下面的BUILD.gn文件在features处把startup改成hello 然后保存 import(&quot;//build/lite/config/component/lite_component.gni&quot;) lite_component(&quot;app&quot;) &#123; features = [ &quot;hello&quot;, ] &#125; 备注头文件位置：&#x2F;&#x2F;鸿蒙根目录&#x2F;utils&#x2F;native&#x2F;lite&#x2F;include 到此编译成功编译输出的文件位置&#x2F;&#x2F;鸿蒙根目录&#x2F;out&#x2F;wifiiot_hispark_pegasus&#x2F;Hi3861_wifiiot_app_allinone.bin(只是拿hi3861芯片举例其他芯片可能不适用)","tags":"openharmony ubuntu"},{"title":"openharmony用ubuntu图形化页面快速部署","url":"/2024/09/13/openharmony用ubuntu图形化页面快速部署/","text":"openharmony用ubuntu图形化页面快速部署上一期 openharmony用ubuntu源码下载 镜像下载文章内文件 我们打开Ubuntu 用火狐打开https://device.harmonyos.com/cn/develop/ide 将下载的文件解压出来 在解压出来的路径下右键终端打开 ls -l /bin/sh执行如下命令，确认输出结果为bash。如果输出结果不是bash输入sudo dpkg-reconfigure dash打开终端工具，执行如下命令，输入密码，然后选择No，将Ubuntu shell由dash修改为bash。 然后开始安装HUAWEI DevEco Device Tool右键解压出来的文件 点属性 权限 勾选上允许执行文件再右键在终端打开（一定要在安装文件路径下打开）sudo ./devicetool-linux-tool-&#123;这里改为你下载的版本号&#125;.sh -- --install-plugins 比如sudo ./devicetool-linux-tool-3.0.0.400.sh -- --install-plugins 在用户协议和隐私声明签署界面，请详细阅读用户协议和隐私声明，需签署同意用户协议和隐私声明才能进行下一步的安装.上下键选择左右键是确定和取消按 回车键确定 如果报错有几个包无法下载输入 sudo apt-get update然后会安装好带vscode的版本 打开vscode点击工程导入工程 然后点击打开工程我们选择好工具链的位置&#x2F;鸿蒙根目录&#x2F;prebuilts然后选择好版本 点击安装他会自动补全工具链 如果出现权限不够终端输入，然后重启vscodesudo code --user-data-dir=&quot;~/.vscode-root&quot; 这里选择好芯片以下拿HI3861举例记下自己的编译芯片名称 打开这个和刚刚的编译名称一样点击build就可以编译了 已经完成编译， 生产的文件在&#x2F;鸿蒙根目录&#x2F;out&#x2F;hispark_pegasus&#x2F;wifiiot_hispark_pegasus&#x2F;Hi3861_wifiiot_app_allinone.bin （不同芯片可能不一样）","tags":"openharmony ubuntu"},{"title":"arduino基于stm32环境搭建","url":"/2024/09/13/arduino基于stm32环境搭建/","text":"arduino基于stm32环境搭建Stm32使用arduino开发在线安装:https://github.com/arduino/Arduino/wiki/STM32 core (official): https://github.com/stm32duino/BoardManagerFiles/raw/main/package_stmicroelectronics_index.jsonProvide support of the following STM32 series:STM32F0, STM32F1, STM32F2, STM32F3, STM32F4, STM32F7STM32G0, STM32G4STM32H7STM32L0, STM32L1, STM32L4, STM32L5,STM32MP1 (Cortex-M)STM32U5STM32WB, STM32WL 因为其中的某个部件的github链接已经失效，下面介绍离线的安装方法 打开hfs软件，把软件端口改8080 把cmsis–5.7Stm32-2.3.0Stm32toolsXpack–arm–none–eabi–gccPackage–stmicroelectronics–index.json等文件拖入hfs软件 点击Package–stmicroelectronics–index.json文件，复制上面的链接 打开arduino ide软件(安装链接) 左上角文件点击首选项 在其他开发者管理器地址粘贴刚刚复制的链接 点击arduino开发版管理器(在软件的左边菜单处) 选择安装stm32 mcu based board(注意版本不要修改，因为没准备其他版本的文件) 然后点安装Arduino就会自动安装了到此软件配置完成 注：如果新版本出现卡在某一处不动的情况，可以把hfs关掉再重新打开，然后重新安装。按照这个步骤多试几次就可以完成安装。 本文工具下载","tags":"stm32 arduino"},{"title":"openharmony用ubuntu源码下载","url":"/2024/09/12/openharmony用ubuntu源码下载/","text":"openharmony用ubuntu源码下载第一种官方文档 记得拉到下面点击你要下载的版本拿鸿蒙3.0举例https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v3.0-LTS.md 就可以直接下载了 直接把源码放到ubuntu里面解压就可以了 第二种repo加http下载 执行如下命令，确认输出结果为bashls -l /bin/sh如果输出结果不是bash 打开终端工具，执行如下命令，输入密码，然后选择No，将Ubuntu shell由dash修改为bash。sudo dpkg-reconfigure dash 然后切换源镜像为清华源 https://mirrors.ustc.edu.cn/repogen/ 这里记得切换版本 切换好点下载 然后备份之前的源文件（文件路径&#x2F;etc&#x2F;apt&#x2F;sources.list）sudo cp /etc/apt/sources.list /etc/apt/source.list.bak把sources.list文件备份成sources.list.bak路径不变 把下载的清华源sources.list替换原本的文件sudo mv -f (这里修改你下载的sources.list文件的路径) /etc/apt/输入下面命令更新源sudo apt update 安装环境，有两个命令第一条 sudo apt-get install binutils binutils-dev git git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 bc gnutls-bin python3.8 python3-pip ruby genext2fs device-tree-compiler make libffi-dev e2fsprogs pkg-config perl openssl libssl-dev libelf-dev libdwarf-dev u-boot-tools mtd-utils cpio doxygen liblz4-tool openjdk-8-jre gcc g++ texinfo dosfstools mtools default-jre default-jdk libncurses5 apt-utils wget scons python3.8-distutils tar rsync git-core libxml2-dev lib32z-dev grsync xxd libglib2.0-dev libpixman-1-dev kmod jfsutils reiserfsprogs xfsprogs squashfs-tools pcmciautils quota ppp libtinfo-dev libtinfo5 libncurses5-dev libncursesw5 libstdc++6 gcc-arm-none-eabi vim ssh locales libxinerama-dev libxcursor-dev libxrandr-dev libxi-dev 第二条 sudo apt-get install gcc-arm-linux-gnueabi gcc-9-arm-linux-gnueabi 配置Python设置默认Python解释器，python和python3软链接为python3.8： sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 1 sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1 python --version 安装python包管理工具（pip3）： sudo apt install python3-pip 配置pip软件包更新源： mkdir ~/.pip pip3 config set global.index-url https://mirrors.huaweicloud.com/repository/pypi/simple pip3 config set global.trusted-host mirrors.huaweicloud.com pip3 config set global.timeout 120 安装Samba服务用于在开发环境中使用VS Code编写代码。执行下列命令安装samba并打开配置文件： sudo apt install samba sudo gedit /etc/samba/smb.conf 在配置文件末尾添加以下内容： [home] comment = User Homes path = /home guest ok = no writable = yes browsable = yes create mask = 0755 directory mask = 0755 建立用户并设置密码（请将下面的用户名换成您自己的）： sudo smbpasswd -a （你自己的用户名） 重启samba： sudo service smbd restart 安装git-lfs，会自动安装git： sudo apt install git-lfs 安装repo和requests： wget https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 sudo mv repo-py3 /usr/local/bin/repo sudo chmod a+x /usr/local/bin/repo pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests 配置git（请将下面的邮箱和用户名换成您自己的）： git config --global user.email &quot;你的邮箱@邮箱域名&quot; git config --global user.name &quot;名称&quot; git config --global credential.helper store git config --global --add safe.directory &quot;*&quot; 然后以上就完成了基本环境安装 接下来我们进行http源码下载 我们先创建目录这样看起来不会太乱 mkdir -p ~/openharmony cd ~/openharmony 然后我们打开官方文档官方文档 找到你要下载的版本我们拿3.0lts举例 我们要复制的是htpp的链接 repo init -u （复制的链接） repo sync -c repo forall -c &#39;git lfs pull&#39; 然后就可以下载源码了 第三种gitee教程 ssh下载上面的环境安装保持不便，如果已经安装环境的话就不用修改了 首先我们先注册公钥终端输入命令生成密钥 ssh-keygen输入完之后一直回车这样就完成了 输入命令查看公钥cat ~/.ssh/id_rsa.pub复制这个一大串的东西 然后我们打开gitee登录自己账号点击设置，点SSH公钥，粘贴刚刚复制的一大串东西终端输入命令测试ssh -T git@gitee.com如果出现这个页面那就输入yes，再重新输入命令就好了 这样就是配置好公钥了 然后我们打开官方文档官方文档 找到你要下载的版本我们拿3.0lts举例 这次我们选择复制第一个链接 我们先创建目录 mkdir -p ~/openharmony cd ~/openharmony 然后是在目录下面输入这些命令 repo init -u 你刚刚复制的链接 repo sync -c repo forall -c &#39;git lfs pull&#39; 这样就可以正常的通过ssh下载了","tags":"openharmony ubuntu"},{"title":"STM32标准库GPIO","url":"/2024/03/27/STM32标准库GPIO/","text":"STM32标准库GPIO作为STM32最基本的外设，GPIO最基本的输出功能是由STM32控制 引脚输出高低电平，比如可以把GPIO接LED灯来控制其亮灭，也可以接继电器或者三极管，通过继电器或三极管来控制外部大功率电路的通断。 这是大概到结构图，看的懂就看，看不懂就算了。 STM32一共是有8种模式输入模式：（1）GPIO_Mode_IN_FLOATING 浮空输入（2）GPIO_Mode_IPU 上拉输入（3）GPIO_Mode_IPD 下拉输入（4）GPIO_Mode_AIN 模拟输入输出模式：（5）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）（6）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）（7）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）（8）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉） 先来介绍输出模式 在开漏输出模式时，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I&#x2F;O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I&#x2F;O端口的电平就不会由输出的高电平决定，而是由I&#x2F;O端口外部的上拉或者下拉决定 如果没有上拉或者下拉 IO口就处于悬空状态（省流，能输出大电流，但是可能会短路） 在推挽输出模式时，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I&#x2F;O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I&#x2F;O端口的电平就是高电平，外部上拉和下拉的作用是控制在没有输出时IO口电平（省流，只能输入弱电流，需要上拉可以保护避免短路） 输入模式上拉就是悬空就是高电平下拉就是悬空就是低电平浮空输入就是不上拉不下拉，容易干扰 下面内容建议配合代码查看（stm32f103c8t6）配置GPIO步骤 1 开启gpio时钟2 配置GPIO初始化3 调用 开启gpio时钟而相对应的外设功能所使用的时钟 在stm32f4xx.h 中即可查看到 1RCC_AHB1PeriphClockCmd ( RCC_AHB1Periph_GPIOX, ENABLE); /*开启 AHB1时钟*/ X是选择引脚组ENABLE开DISABLE 关 RCC_AHB1 RCC_APB1 配置GPIO初始化1GPIO_Init(GPIOX, &amp;GPIO_InitStructure); //初始化所设置的引脚 X是初始化引脚组为ABCD等组GPIO_InitStructure 是结构体用于初始化 1GPIO_InitTypeDef GPIO_InitStruct; //定义初始化结构体 定义完结构体后就可以对结构体进行配置 GPIO_InitStruct.GPIO_Mode &#x3D; x; &#x2F;&#x2F;配置模式模式上面有GPIO_InitStruct.GPIO_Pin &#x3D; GPIO_Pin_X; &#x2F;&#x2F;配置哪个IO口一共有1到16个引脚GPIO_InitStruct.GPIO_Speed &#x3D; GPIO_Speed_xMHz; &#x2F;&#x2F;配置IO口速度,仅输出有效 gpio的速度 调用输出 1GPIO_ResetBits(GPIOX, GPIO_Pin_X); //X组，x引脚 gpio引脚低电平 1GPIO_SetBits(GPIOX, GPIO_Pin_X); //X组，x引脚 gpio引脚高电平 1GPIO_SetBits(GPIOX, GPIO_Pin_X); //X组，x引脚 gpio引脚高电平 1GPIO_WriteBit(GPIOX, GPIO_Pin_X, Bit_RESET);//X组，x引脚 gpio引脚低电平 1GPIO_WriteBit(GPIOX, GPIO_Pin_X, Bit_SET);//X组，x引脚 gpio引脚高电平 1GPIO_WriteBit(GPIOX, GPIO_Pin_X, X);//X组，x引脚 X可以为高低电平 输入 1GPIO_ReadInputDataBit(GPIOX, GPIO_Pin_X) //X为组 X为引脚 这个就可以检测高低电平用if判断上面的函数为1或者0就是高或者低 参考工程：https://wwm.lanzouq.com/b03lno3za密码:6jed","tags":"stm32"},{"title":"STM32开发环境","url":"/2024/03/26/STM32开发环境/","text":"STM32开发环境stm32开发有标准库开发，hal库，还有寄存器开发。因为stm32主要是32位单片机，32位单片机也就导致了stm32的寄存器不好配置所以，我也就不暂时不想介绍stm32的寄存器开发。 现在，先说一下最常见的标准库开发。（标准库目前官方已经停更，未来主要还是hal库的开发方式）标准库只支持 ：F0，F1，F2，F3，F4，L1官方网站：跳转开发软件使用的keil mdk版本 Keil介绍 在完成keil软件的安装以后。还要安装stm32专用的芯片库，只有对应库才能正常的编译。 STM32库：https://www.123pan.com/s/siA6Vv-859uA.html 方法1下载之后，一般可以双击直接安装 方法2如果不行，可以用第二种安装方式点这个小方块 在左上角，点这个位置，选择库的包然后就可以安装了。","tags":"stm32"},{"title":"Keil介绍","url":"/2024/03/26/Keil介绍/","text":"Keil介绍：keil是一款主流的单片机开发工具，目前已经被arm收购。官网下载:http://www2.keil.com/mdk5我提供的下载：https://www.123pan.com/s/siA6Vv-D59uA.html51版本：https://www.123pan.com/s/siA6Vv-r59uA.html我提供的版本不是最新版本，但是有较为完整的汉化，虽然不知道是谁汉化的，但是能够汉化的如此完整我觉得也是够牛逼的。同时，说一下keil如果不破解的话，只能编译少量的代码。只有破解了才能完整的编译。 安装keil分arm版本和c51版本。ARM版本可以向下兼容C51，C51不兼容ARM。所以建议ARM版本。 首先是正常的安装流程。点击Next&gt;&gt;打勾，然后Next&gt;&gt;选择安装路径，建议默认即可。Next&gt;&gt;随便写点什么。Next&gt;&gt;什么都可以填自己马马也行反正就是安装完成了。要中文版本，就要在你的安装软件目录里面找到Keil_v5\\UV4找到uv4.exe直接覆盖就好了 安装兼容51版本前面的安装流程是一样的不要修改安装路径 直到遇到这个页面，然后一直点skip跳过就可以，要按无数次。 激活下面是破解教程只是提供学习目的，如果需要支持正版，请到ARM官网购买，或者到ARM注册社区版。如果你真心是要社区版请到下面。 正常破解流程。安装完毕之后，请右键管理员运行keil软件。 请右键管理员运行keil软件。请右键管理员运行keil软件。请右键管理员运行keil软件。不管理员打开破解不成功别找老子 打开软件这个页面 复制好你的Cid然后放入破解软件里面。如果你是ARM版本就选择ARM，是C51就选择C51。我提供的版本是ARM版本，选择ARM。如果你还安装了我的C51兼容keil。那么C51，ARM都要激活要输入两次激活码。 点击Generate，将生成的代码复制。粘贴到如图所示，点击Add LIC。出现如图所示表示破解完成。到这KEIL5的安装算是完成了。如果破解不成功，就是没管理员打开keil破解到2035年。有人担心过去咋办，其实不用担心，就算到了2035年以后，软件还是能用，只是会提醒你要续费。只是ARM官网目前最长到2035年，2035年以后肯定还有新的破解的。 如果你的ARM和51版本破解过后应该是这样的 到此软件已经安装完成","tags":"stm32 51 mdk"},{"title":"STM32奇怪的文档目录","url":"/2024/03/26/STM32奇怪的文档目录/","text":"本教程为STM32的教程目录： STM32开发环境 STM32F103c8t6标准库开发教程： io输出STM32标准库GPIO IO读取STM32标准库GPIO 中断 定时 PWM AD","tags":"stm32"},{"title":"树莓派入门到入坟教程3","url":"/2023/11/10/树莓派入门到入坟教程3/","text":"上一期安排了树莓派的gpio的环境安装这次看看树莓派的gpio的开发。gpio可以使用shell，c，python。我个人使用的是python开发（为什么，没有理由你管我？） 我们检查python环境（一般来说都是默认安装的）python这个命令可以检查python版本号 这里面有参考代码https://wwwe.lanzouq.com/ik7J71esdn6b密码:bybd我们直接把代码文件拖到树莓派的桌面（这里不过是用桌面来举例子）切换路径cd Desktop这个命令运行桌面里面xxx.py文件python xxx.py当然你也可以直接双击打开 python代码建议看菜鸟教程","tags":"树莓派"},{"title":"树莓派入门到入坟教程2","url":"/2023/11/10/树莓派入门到入坟教程2/","text":"这里我们介绍一下树莓派的gpio的开发首先我们来安装gitsudo apt install git-core输入以下命令，将 WiringPi 文件下载到树莓派系统的当前目录。sudo git clone https://github.com/WiringPi/WiringPi输入以下命令进入 WiringPi 文件夹目录。cd WiringPi/输入以下命令安装 WiringPi。sudo ./build 到处我们完成了gpio的安装我们可以用命令查看gpio版本gpio -v这个命令可以查看gpio的引脚gpio readall然后环境就完成了安装","tags":"树莓派"},{"title":"github入门到入土","url":"/2023/11/08/github入门到入土/","text":"github通过ssh连接上传项目到库首先我们先在电脑里面下载一个git git git用于项目管理。然后我们在github上面注册github账号还有创建一个仓库。如果要用github去托管静态网站的话，需要github开启为公开库一般都是默认公开库 我们安装完成git之后打开你要上传的项目位置 然后我们输入初始化仓库 git init 然后我们登录自己的邮箱与名字 git config --global user.email&quot;邮箱&quot; git config --global user.name&quot;名字&quot; 之后再把文件给添加到本地库 git add . git commit -m &quot;first commit&quot; 完成之后，如果查看隐藏文件夹，那么可以看到.git的隐藏文件 然后将本地的仓库关联到github上第一步：创建SSH KEY 先看一下C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步， 没有就通过下面命令创建：先创建.ssh目录在C盘用户目录 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 输入完后不要输入任何命令直接回车直到出来奇怪的字符就是完成了然后应该会有.ssh目录里是有id_rsa和id_rsa.pub这两个文件的 第二步：登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。第三步： 找到自己的仓库地址，然后可以连接了！下图是没有readme文件的时候👇有readme文件时是这样👇 git remote add origin https://github.com/HiW666/HiW666.github.io.git origin 后面是自己的仓库url地址 代码上传到GitHub仓库 git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了： git push origin master 在上面创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第8 将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/…git的错。这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并一下： git pull --rebase origin master 最后如果你真的没办法就用这个吧 git push -f origin master （这个会强制覆盖，如果经常这样搞迟早会出事） 再最后提一嘴如果你是打算拿github搭建静态服务器的。每次上传完成之后，域名都要重新解析这个以后有机会再出一期吧","tags":"github"},{"title":"树莓派如何进行ssh连接","url":"/2023/11/08/树莓派如何进行ssh连接/","text":"ssh连接关于我为什么要把树莓派的ssh连接分开来说因为我个人感觉，树莓派运行的系统是Linux的系统，所以也就相当于是介绍Linux的系统的ssh的远程连接，所以我就新开了一个章节来介绍树莓派如何ssh远程连接（其实是Linux系统的远程连接了啦） 我这边推荐的是远程登录软件MobaXterm（当然如果你会，你也可以用自己上手的） MobaXterm 打开远程登录软件MobaXterm：点击session，点击ssh，在Remote host输入树莓派的IP地址：（如果不会的话看上一期，或者自行百度同一局域网如何查询设备ip树莓派入门到入坟教程1）Specify usemame输入用户名pi登录名为pi，密码是raspberry（注意输入密码过程不会有显示，所以要注意输入法） 下面使用vnc进行远程桌面首先在终端sudo raspi-config依次操作：Interfacing Options -&gt; VNC -&gt; Yes。之后系统会提示你是否要安装 VNC 服务，输入 y 之后回车，等待系统自动下载安装完成，一切顺利的话 VNC 服务就启动了！完成之后 VNC下载 打开VNC输入树莓派的IP地址：选择Continue：Username：pi Password：raspberry ：这里就登录成功了： 到此树莓派ssh就完成连接了 补充关于文件传输我们可以使用MobaXterm进行文件传输当我们连接完成之后，右边这里会显示树莓派的文件路径我们只需要把文件拖入进去就可以传输文件了同理，我们把文件拖出来，可以把文件传出来","tags":"树莓派 linux"},{"title":"树莓派入门到入坟教程1","url":"/2023/11/07/树莓派入门到入坟教程1/","text":"树莓派入门到入坟教程1写这玩意，绝对不是因为树莓派是理财产品也不是为了让他死灰复燃，让他发挥出更大的意义。问我他有什么用，我也不知道，反正是花了好大功夫，才勉强从老师的手里里面借出来的。（www，真没钱买这东西） 关于树莓派这东西，可以说是一个小主机吧，比起单片机来说更多是要一个操作系统来控制他。首先，我们需要一张tf卡来安装系统。我们在安装操作系统之前先要把tf来进行格式化sd卡格式化工具 然后有两种安装方法 树莓派官方安装工具官方工具蓝奏云密码:6btjRaspberry Pi OS with desktop版本的特点是有电脑桌面，对于普通用户来说，这个就够用了。Raspberry Pi OS Lite版本特点是没有电脑桌面，进入系统所有操作都要用命令行，由于没有UI界面，适合TF卡容量小和熟练掌握Linux操作使用，如果您没有linux基础，使用起来会非常艰难，入门还是建议选择带桌面的镜像。 将TF卡连接电脑。打开 Raspberry Pi Imager选择所需的操作系统。选择要写入图像的 TF 卡(注意：最好移除其它U盘设备，以防将U盘文件擦除)。预先配置系统，按住 CTRL+SHIFT+X(或点击右下角小齿轮)，设置完成点击保存即可。单击烧录按钮，将数据写入TF卡。 其他系统烧录镜像可以使用其它方法，使用镜像写入工具将下载好镜像写入树莓派，例如：balenaEtcher或Win32DiskImager 。首先去树莓派官网下载镜像，推荐使用Raspberry Pi OS with desktop。树莓派官方系统下载 打开对应的烧录工具Win32DiskImager将TF卡插入读卡器，将读卡器插入电脑。选择下载好的树莓派镜像文件。单击“写入”并等待写入完成。 树莓派开机然后完成上面的步骤树莓派就可以开机了但是要注意，树莓派要先连接好外设之后再启动主机，而且强调供电要5v3a的电源 下面的教程适用于没有hdmi或者键盘，鼠标外设的人使用的 树莓派ssh配置开启sshboot盘符下新建一个名为ssh的文件，不要任何扩展名不要任何扩展名，不要任何扩展名，不要任何扩展名你可以新建一个ssh.txt,确保文件夹选项中的设置是显示扩展名的，然后将.txt删除，这样你就获得了一个没有任何扩展名的名为ssh的文件。 然后我们要给树莓派连接wifi我们继续在boot新建一个记事本重命名为wpa_supplicant.conf 记事本里面内容打开并输入对应内容（’假设我在中国，无线名称test，无线密码密码为12345678） &#96;country&#x3D;CNupdate_config&#x3D;1ctrl_interface&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant network&#x3D;{ssid&#x3D;”test”psk&#x3D;”12345678”key_mgmt&#x3D;WPA-PSK}&#96; 然后我们要获取树莓派的ip我们可以登录路由器的后台查看或者自己百度如何获取局域网设备的ip这里不细说 树莓派ssh配置去看树莓派ssh连接教程本人就先不放在本篇里面了 树莓派如何进行ssh连接","tags":"树莓派 linux"},{"title":"hexo搭建教程","url":"/2023/11/07/hexo搭建教程/","text":"搭建使用hexo静态博客静态网站相较于动态网站更加安全，响应速度更快（应该是吧，不是的话当我在放屁）最重要的是github允许使用静态网站这不就是直接白嫖一台服务器了然后我们可以使用hexo白嫖github下面教程教大家如何配置hexo 教程1 配置环境2 hexo安装 （如果已经建过网站的可以跳过这个）3 hexo运行4 hexo目录介绍5 如何开发 配置环境（以上只适用于window，其他系统请参考官网文档）首先我们来安装gitgit官网下载 然后我们来安装Node.js的框架官网下载如果打开不了可以用淘宝镜像淘宝镜像实在不行用我的链接（不保证是最新版本）蓝奏云密码:aiza 安装完成环境之后我们win＋r按键打开cmd输入下面的命令$ npm install -g hexo-cli 之后就完成了环境的安装了 hexo安装首先我们可以用 命令行cd XXX来修改路径，XXX填路径切换路径之后命令行hexo init &lt;folder&gt; hexo会生成网站的源码&lt;folder&gt;是网站的文件夹名称 4 运行我们可以用hexo generate来编译生成网站代码简写hexo g有代码后我们可以用（其实直接 hexo s也就能同时编译和启动服务器）hexo server来启动服务器简写hexo s如果要修改端口XXX为端口hexo server -p XXX简写hexo s -p XXX自定义iphexo server -i 192.168.1.1简写hexo s -i 192.168.1.1 hexo目录介绍├── _config.yml├── package.json├── scaffolds├── public├── source| ├── _drafts| └── _posts└── themes _config.yml是站点配置 package.json应用程序的信息。EJS, Stylus 和 Markdown 渲染引擎 已默认安装，您可以自由移除。 scaffolds是hexo本体文件 public是hexo编译出来的网站代码 source是写文章其中里面的_posts是文章的地方你也可以新建tags（标签），about（网站介绍）categories（分类），img（网站文件）等等 themes是放主题的地方刚刚初始化的网站可能没有 tags，about，cetegories文件 hexo new page xxx可以进行生成tags，about，cetegories等文件（xxx为要填写生成的标题） 5 如何开发_config.yml是站点配置 关于配置参数 描述title 网站标题subtitle 网站副标题description 网站描述keywords 网站的关键词。支持多个关键词。author 您的名字language 网站使用的语言。对于简体中文用户来说常见的有 zh-Hans和 zh-CN。timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America&#x2F;New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia&#x2F;Shanghai。值得一提的是你可以在文件末尾处找到一个theme:的配置这里面用于设置你的主题 source的新建教程 除了在_posts里面写文章外（文章可以用md开发）你还可以在里面新建tags（标签），about（网站介绍）categories（分类），img（网站文件）等文件夹然后创建index.md的文件index.md文件参考title是新建的文件夹的名称date:是日期 文章编写以及主题修改请看下篇关于如何部署到github请看如何提交项目到github也不在此处 github入门到入土 官方教程","tags":"hexo"},{"title":"cadence教程操作2","url":"/2023/11/07/cadence软件教程操作2/","text":"cadence教程操作2这里没例子只是单纯的软件的功能介绍 图层的绘制这是材料名称这些是快捷键 我们先点击左侧的图层栏选择我们要的材料二极管我们先选择co然后在主页面看鼠标然后按下键盘上面的r按键然后就可以开始绘画了然后画完成之后按下esc就可以退出绘画模式鼠标又会变成这样然后再用鼠标选中再按下q按键就可以设置图层的大小了 图层的关系这样是全部的图层这个是已经使用的图层然后这个位置可以修改图层是否可见（也就是隐藏图层） 标记图层打开这里选择pin然后就可以给图层定义 然后关于电阻，电容，电感的绘制的教程文档","tags":"cadence"},{"title":"cadence教程操作1","url":"/2023/11/06/cadence软件教程操作1/","text":"关于cadence软件的一些基本的操作本篇文章只是说明软件的一些启动，不包括软件安装与linux系统的安装（vm虚拟机配置也不在这里了啦！） 关于软件的基本使用逻辑1建立库2关联库3打开图层 1，安装软件成功以后在终端里面输入icfb 或者 virtuoso 启动软件 等待一会直到出现下面的页面为止 2，关于软件的基本页面 （关于软件的设置启动设置，5.1版本默认只有一步撤销动作，可以设置最大10步撤销动作，6.1版本有128步撤销动作） 3软件的使用开始建立软件库首先主页打开库管理开始新建库选择保存库的路径 然后点ok然后选择第三个 然后点ok选择常用单元 然后点ok到此为止已经建立了库然后开始新建图层但是建立完库后发现，库的右边全部都是空白的。这个时候，我们要进行关联库。 4关联库我们先导入库这里用中芯国际的库来举例子中芯国际库的下载链接密码:btxs 我们把中芯国际的库和其他的库的库统一放在一起 （提醒一下这里是查看库的保存路径） 然后我们返回到软件的主页点击这里关联库 然后开始关联库上面是自己的库下面选择要关联的这样我们就和中芯国际的库关联好了然后我们重新打开刚刚的图层就会发现图层已经有了下篇我们教大家如何绘制元器件 参考的文档","tags":"cadence"},{"title":"你说的队但我可以嘎嘎乱杀","url":"/2023/07/27/嵌入式你说的队但我可以嘎嘎乱杀/","text":"stm开发工具打包 各类开发板原理图 欣柯易电子 天问Block软件下载链接：www.twen51.com欣柯易电子 ASR-PRO官方资料汇总以及上手视频：https://www.haohaodada.com/new/bbs/forum.php?mod&#x3D;viewthread&amp;tid&#x3D;592&amp;page&#x3D;1&amp;extra&#x3D;#pid1355注意：我们的ASR PRO开发板已经板载CH340芯片，Type-C数据线可以一键下载！核心板和官方一致！成柯易电子 ASR-PRO语音模块资料：https://pan.baidu.com/s/1G7CmqwLbJxLbFuk1nH6miQ提取码：1234https://wwwe.lanzouq.com/iYeJb13mxkwh esp 32cam https://wwwe.lanzouq.com/itssF13morwf 433频段 https://wwwe.lanzouq.com/iXv6m13my2tc stm32开发库 超声波模块寻迹小车 7z解压缩https://wwwe.lanzouq.com/ibbgw13nq0la密码:g6k2 电赛参考论文密码:fg60","tags":"stm32"},{"title":"hexo写作开发手册","url":"/2023/07/26/hexo手册/","text":"欢迎观看hexo文章写作手册 此处直接写文章 手册参考https://gitee.com/KSweb/Markdown/tree/master 此处为大号字体可做为标题此处为小标题代码跳转 标记 $ 重点 代码生成(已经弃用，因为会导致不知名的gcc编译错误) #include &lt;stdio.h&gt; int main&#40;&#41; &#123; printf&#40;&quot;Hello, World!&quot;&#41;; return 0; &#125; &nbsp; #include &lt;stdio.h&gt; int main() &#123; printf(&quot;Hello, World!&quot;); return 0; &#125; 图片 hexo搭建教程 外链音乐","tags":"hexo"},{"title":"产品资料","url":"/songse/index.html","text":"开发板系列菘果派e1系列基本资料 菘果派e1系列基本资料 资料整合:arduino系列教程arduino系列教程 openharmony南向开发系列openharmony南向开发教程","tags":""},{"title":"网站日志","url":"/about/index.html","text":"本网站现阶段主要是我的个人博客主要用于分享一些各种各样的知识。目前资料也就由HiW整理发出。大部分也会参考其他网站上面的一些资料所以，如果有侵权，请联系我。目前托管在github联系:邮箱&#x48;&#x69;&#x57;&#64;&#x62;&#x69;&#110;&#103;&#x69;&#x6e;&#x67;&#x2e;&#x74;&#111;&#x70; 项目贡献bnging.combinging.comHiWgithub.com 更新日志： 2023&#x2F;12&#x2F;19:由freecdn提供了cdn加速 2023&#x2F;12&#x2F;18:更新了本地站点搜索同时更新了关于我们 2023&#x2F;12&#x2F;17:更新了hexo架构 2024&#x2F;9&#x2F;14:移除freecdn的cdn加速，并且去除页脚 2024&#x2F;9&#x2F;14:重启启用binging.top域名并且由cloudflare提供cdn加速和dns解析（bnging.com域名保持不变但是无加速） 2024&#x2F;9&#x2F;15:顺带修复了一些代码显示不正确的bug 2024&#x2F;9&#x2F;16:采用了新的代码块进行编译 2024&#x2F;9&#x2F;19:紧急更新弃用了菜鸟编程的代码块生成，会导致不知名的编译错误 2024&#x2F;11&#x2F;22:更新了封面，加载页面，加入了下载资料（为全新的产品做准备） 2024&#x2F;11&#x2F;26:更新了封面，更加好看了呢，欸嘿我们上架了第一款产品菘果派e1，当然还在开发ing，目前只有arduino的，keil的资料还没整理，别急哦！！！我们已经为arduino做看归档，这样查询更加方便。 2024&#x2F;12&#x2F;10:下方更新了资料整合方便查找 2024&#x2F;12&#x2F;10:把关于我们改成了网站日志，同时把资料整理置顶方便查找 2024&#x2F;12&#x2F;27:系列教程转移至资料下载里面 2024&#x2F;12&#x2F;27:更新了全新的代码函数显示方法，之前的暂时未更新","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""}]}